<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript,设计模式,">










<meta name="description" content="JavaScript的23种设计模式   范围/目的 创建型模式 结构型模式 行为型模式     类模式 工厂方法 （类）适配器 模板方法 解释器   对象模式 单例 原型 抽象工厂 建造者 代理 （对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录">
<meta name="keywords" content="JavaScript,设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript设计模式">
<meta property="og:url" content="https://blog.xiekaifei.com/2023/js-design-patterns.html">
<meta property="og:site_name" content="谢凯飞的博客">
<meta property="og:description" content="JavaScript的23种设计模式   范围/目的 创建型模式 结构型模式 行为型模式     类模式 工厂方法 （类）适配器 模板方法 解释器   对象模式 单例 原型 抽象工厂 建造者 代理 （对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2023-11-18T14:52:29.355Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript设计模式">
<meta name="twitter:description" content="JavaScript的23种设计模式   范围/目的 创建型模式 结构型模式 行为型模式     类模式 工厂方法 （类）适配器 模板方法 解释器   对象模式 单例 原型 抽象工厂 建造者 代理 （对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.xiekaifei.com/2023/js-design-patterns.html">





  <title>JavaScript设计模式 | 谢凯飞的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f824212f964fe1dcdbfd0c78349270a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谢凯飞的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">blog.xiekaifei.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.xiekaifei.com/2023/js-design-patterns.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaifei Xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://cdn.xiekaifei.com/image/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢凯飞的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript设计模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-06-04T22:26:12+08:00">
                2023-06-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JavaScript的23种设计模式"><a href="#JavaScript的23种设计模式" class="headerlink" title="JavaScript的23种设计模式"></a>JavaScript的23种设计模式</h1><table>
<thead>
<tr>
<th>范围/目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>类模式</td>
<td>工厂方法</td>
<td>（类）适配器</td>
<td>模板方法 解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例 原型 抽象工厂 建造者</td>
<td>代理 （对象）适配器 桥接 装饰 外观 享元 组合</td>
<td>策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>本篇博客介绍了 JavaScript 的23种设计模式，其中大部分思想与示例来自于<a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">《JavaScript设计模式与开发实践》</a>一书，所以本文更像是我对该书的学习笔记，书中没有讲到的设计模式经过其他途径学习总结后均有提到。传统的面向对象程序设计语言有23种设计模式，本文中的部分设计模式可能仅仅是为了让未来的自己和读者了解其设计思想（如解释器模式），在实际开发中很少用到。</p>
<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><blockquote>
<p>在软件工程中，<strong>设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。</strong>这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。</p>
</blockquote>
<blockquote>
<p><strong>设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。</strong>面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。</p>
</blockquote>
<blockquote>
<p>并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。</p>
</blockquote>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例（Singleton）模式"><a href="#单例（Singleton）模式" class="headerlink" title="单例（Singleton）模式"></a>单例（Singleton）模式</h2><p>单例模式即<strong>保证一个类仅能有一个实例，且全局可以访问该实例</strong>。</p>
<p>其实现原理是：创建实例时，缓存实例，后面创建时先判断有没有创建过，有的话直接返回。也就是说主要实现逻辑在缓存实例这里，我们可以用静态属性、闭包、重写构造函数等几种不同的方式来实现单例模式。</p>
<p>单例模式实际大多应用在只存在唯一一个实例的场景，如登录框、统一页面浮窗等。</p>
<h3 id="静态属性实现单例模式"><a href="#静态属性实现单例模式" class="headerlink" title="静态属性实现单例模式"></a>静态属性实现单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Singleton.instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> Singleton.instance <span class="comment">// 如果有缓存直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> Singleton.instance = <span class="keyword">this</span> <span class="comment">// 将静态属性instance设置为首个实例（缓存）</span></span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Singleton(<span class="string">'s1'</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Singleton(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true，说明两个实例是同一个</span></span><br><span class="line">s2.sayName() <span class="comment">// 's1'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> instance <span class="comment">// 定义一个静态属性</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Singleton.instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> Singleton.instance <span class="comment">// 如果有缓存直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> Singleton.instance = <span class="keyword">this</span> <span class="comment">// 将静态属性instance设置为首个实例（缓存）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Singleton(<span class="string">'s1'</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Singleton(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true，说明两个实例是同一个</span></span><br><span class="line">s2.sayName() <span class="comment">// 's1'</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包实现单例模式"><a href="#闭包实现单例模式" class="headerlink" title="闭包实现单例模式"></a>闭包实现单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span> <span class="comment">// 设置私有变量instance</span></span><br><span class="line">  <span class="keyword">const</span> CreateSingleton = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  CreateSingleton.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CreateSingleton</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Singleton(<span class="string">'s1'</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Singleton(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br><span class="line">s2.sayName() <span class="comment">// 's1'</span></span><br></pre></td></tr></table></figure>
<h3 id="重写构造函数实现单例模式"><a href="#重写构造函数实现单例模式" class="headerlink" title="重写构造函数实现单例模式"></a>重写构造函数实现单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Singleton</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存实例</span></span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写构造函数</span></span><br><span class="line">  Singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保留原型</span></span><br><span class="line">  Singleton.prototype = <span class="keyword">this</span>.constructor.prototype <span class="comment">// 将重写后的构造函数的原型指回原构造函数的原型，使首次声明的实例可以正确访问到原型链上的属性与方法（Singleton.prototype.a = 1，使其生效）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义原型方法</span></span><br><span class="line">  Singleton.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建实例</span></span><br><span class="line">  instance = <span class="keyword">new</span> Singleton()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置构造函数</span></span><br><span class="line">  instance.constructor = Singleton <span class="comment">// 将实例的构造函数指向被重写后的Singleton</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance <span class="comment">// 首次使用该构造函数时，直接返回instance实例。再次使用时因为构造函数已被重写，一样返回instance实例。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.prototype.a = <span class="number">1</span> <span class="comment">// 此时的代码是给重写前的构造函数的原型上添加了属性a</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Singleton(<span class="string">'s1'</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> Singleton(<span class="string">'s2'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor) <span class="comment">// 此时s1.constructor指向重写后的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br><span class="line">s2.sayName() <span class="comment">// 's1'</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="通用（惰性）单例模式"><a href="#通用（惰性）单例模式" class="headerlink" title="通用（惰性）单例模式"></a>通用（惰性）单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createSingleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法用于创建通用（惰性）单例模式。该方法创建出来的单例模式还具有惰性的特点，真正调用的时候单例才会被创建，而不是页面加载后立即被创建。</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = createSingleton(test) <span class="comment">// 使用通用单例模式封装</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = s()</span><br><span class="line"><span class="keyword">const</span> t2 = s()</span><br><span class="line"><span class="built_in">console</span>.log(t1 === t2) <span class="comment">// true，此时生成的两个对象全等，其实返回的始终是一个对象</span></span><br></pre></td></tr></table></figure>
<h2 id="原型（Prototype）模式"><a href="#原型（Prototype）模式" class="headerlink" title="原型（Prototype）模式"></a>原型（Prototype）模式</h2><p><strong>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</strong> 原型模式不单是一种设计模式，也被称为一种编程泛型。 从设计模式的角度讲，原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象<strong>（使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享）</strong>。在其他语言很少使用原型模式，但是JavaScript作为原型语言，在构造新对象及其原型时会使用该模式。</p>
<p>原型上的属性与方法是被实例共享的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原型上添加方法</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">'李四'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHi === p2.sayHi) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为使用原型模式可以使示例共享属性和方法，避免重复创建，可以带来性能上的提升</span></span><br></pre></td></tr></table></figure>
<p>利用以上特性，我们可以实现使用原型模式创建新对象。</p>
<p>ECMAScript 5新增了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a> 方法可以直接使用原型模式创建新对象。</p>
<blockquote>
<p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下示例仅展示Object.create()方法第一个参数的用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.__proto__ === obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是需要注意从原型上继承来的属性和方法具有<strong>动态性</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>Object.create()方法的实现过程（第一个参数）:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心思想是创建一个新的函数，将新函数的prototype属性指向原函数，再返回这个新创建的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法（Factory-Method）模式"><a href="#工厂方法（Factory-Method）模式" class="headerlink" title="工厂方法（Factory Method）模式"></a>工厂方法（Factory Method）模式</h2><p>工厂方法模式是<strong>一个用于创建对象的接口，它提供了一种将实例化逻辑委托给子类的方法。工厂方法允许一个类延迟实例化它使用的子类</strong>。</p>
<p>先来看一下<strong>工厂模式</strong>。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式即抽象了创建 具体对象的过程，将创建对象的过程进行了单独的封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的工厂模式的示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = createPerson(<span class="string">'张三'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = createPerson(<span class="string">'李四'</span>, <span class="number">20</span>)</span><br><span class="line">p1.sayName() <span class="comment">// '张三'</span></span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>正如工厂方法模式的定义所说：</p>
<blockquote>
<p>一个用于创建对象的接口，它提供了一种将实例化逻辑委托给子类的方法。工厂方法允许一个类延迟实例化它使用的子类。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个使用工厂方法模式创建员工的示例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateProgrammer</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 继承基类</span></span><br><span class="line">  <span class="keyword">this</span>.work = <span class="string">'write the code'</span></span><br><span class="line">  <span class="keyword">this</span>.tools = [<span class="string">'computer'</span>, <span class="string">'keyboard'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateDriver</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) <span class="comment">// 继承基类</span></span><br><span class="line">  <span class="keyword">this</span>.work = <span class="string">'drive'</span></span><br><span class="line">  <span class="keyword">this</span>.tools = [<span class="string">'car'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStaff</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(job) &#123; <span class="comment">// 根据参数实例化相应的类</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Programmer'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CreateProgrammer(name, age)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Driver'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CreateDriver(name, age)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数错误，可选参数: [Programmer, Driver]'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = createStaff(<span class="string">'张三'</span>, <span class="number">18</span>, <span class="string">'Programmer'</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = createStaff(<span class="string">'李四'</span>, <span class="number">19</span>, <span class="string">'Driver'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的示例可以让我们通过传入员工的基本信息来创建出任意多个员工，不过员工的类型无法扩展，下面来看一个优化后的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStaff</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> createStaff.prototype[job] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'员工类型错误！'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// createStaff是一个普通函数，而非构造函数，首次不加new运算符使用时，会跑入else代码块</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> createStaff) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>[job](name, age)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> createStaff(...arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">createStaff.prototype = &#123;</span><br><span class="line">  <span class="string">'Programmer'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age) <span class="comment">// 继承基类</span></span><br><span class="line">    <span class="keyword">this</span>.work = <span class="string">'write the code'</span></span><br><span class="line">    <span class="keyword">this</span>.tools = [<span class="string">'computer'</span>, <span class="string">'keyboard'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个员工类型</span></span><br><span class="line">createStaff.prototype.Driver = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age) <span class="comment">// 继承基类</span></span><br><span class="line">  <span class="keyword">this</span>.work = <span class="string">'drive'</span></span><br><span class="line">  <span class="keyword">this</span>.tools = [<span class="string">'car'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = createStaff(<span class="string">'张三'</span>, <span class="number">18</span>, <span class="string">'Programmer'</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = createStaff(<span class="string">'李四'</span>, <span class="number">19</span>, <span class="string">'Driver'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂（Abstract-Factory）模式"><a href="#抽象工厂（Abstract-Factory）模式" class="headerlink" title="抽象工厂（Abstract Factory）模式"></a>抽象工厂（Abstract Factory）模式</h2><p><strong>抽象工厂模式</strong>(Abstract Factory)就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。</p>
<p>抽象工厂模式需要有抽象类来为子类指明必须实现哪些方法，而目前JavaScript没有抽象类的概念，<code>abstract</code> 曾在JavaScript中是保留字（ECMAScript1-3）。我们可以用 <code>throw</code> 语句抛出异常的方式来模拟抽象类和抽象方法。抽象类无法直接被实例化，必须被子类继承使用。而继承了抽象类的子类也必须自行覆盖抽象类中的抽象方法，否则当子类直接调用从抽象类中继承过来的抽象方法时会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先声明四个实体类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'开发者'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Driver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'司机'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monitor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'班长'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GroupLeader</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = <span class="string">'组长'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着定义抽象工厂方法AbstractFactory</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AbstractFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂类无法直接调用'</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractFactory.prototype.createStaff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'无法直接调用抽象方法，子类请实现接口'</span>)</span><br><span class="line">&#125;</span><br><span class="line">AbstractFactory.prototype.createStudent= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'无法直接调用抽象方法，子类请实现接口'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义创建员工工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StaffFactory</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">StaffFactory.prototype = <span class="built_in">Object</span>.create(AbstractFactory.prototype) <span class="comment">// 继承抽象工厂方法</span></span><br><span class="line">StaffFactory.prototype.constructor = StaffFactory <span class="comment">// 保持构造函数具有正确的指向</span></span><br><span class="line">StaffFactory.prototype.createStaff = <span class="function"><span class="keyword">function</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(job) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'programmer'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Programmer()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'driver'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Driver()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数错误，可选参数: [programmer, driver]'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义创建学生工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StudentFactory</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">StudentFactory.prototype = <span class="built_in">Object</span>.create(AbstractFactory.prototype)</span><br><span class="line">StudentFactory.prototype.constructor = StudentFactory</span><br><span class="line">StudentFactory.prototype.createStudent = <span class="function"><span class="keyword">function</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(job) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'monitor'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Monitor()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'group-leader'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GroupLeader()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数错误，可选参数: [monitor, group-leader]'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'staff'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StaffFactory()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'student'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StudentFactory()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'工厂方法不存在'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> staff = <span class="keyword">new</span> Factory(<span class="string">'staff'</span>) <span class="comment">// 创建员工工厂方法</span></span><br><span class="line"><span class="keyword">const</span> staffItem = staff.createStaff(<span class="string">'programmer'</span>) <span class="comment">// 根据员工实体类创建的员工</span></span><br><span class="line"><span class="built_in">console</span>.log(staffItem.title) <span class="comment">// '开发者'</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Factory(<span class="string">'student'</span>)</span><br><span class="line"><span class="keyword">const</span> studentItem = student.createStudent(<span class="string">'monitor'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(studentItem.title) <span class="comment">// '班长'</span></span><br></pre></td></tr></table></figure>
<h2 id="建造者（Builder）模式"><a href="#建造者（Builder）模式" class="headerlink" title="建造者（Builder）模式"></a>建造者（Builder）模式</h2><p>建造者模式将一个复杂的对象分解成多个简单的对象来进行构建，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的 构建层与其表示层分离。</p>
<p>建造者模式包含建造者类、指挥者类和最终生成的产品。用户无需知道用怎样的方式来装配对象，只需要给指挥者类传入类型，由指挥者类决定以怎样的方式装配对象，以得到最终的产品。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个用户类（建造者类）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBuilder</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户类上添加方法</span></span><br><span class="line">UserBuilder.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">UserBuilder.prototype.setGender = <span class="function"><span class="keyword">function</span> (<span class="params">gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="built_in">parseInt</span>(gender)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'男'</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'女'</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'未知'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">UserBuilder.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指挥者类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserDirector</span>(<span class="params">name, gender, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">new</span> UserBuilder()</span><br><span class="line">  user.setName(name)</span><br><span class="line">  user.setGender(gender)</span><br><span class="line">  user.setAge(age)</span><br><span class="line">  <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用（生成一个产品）</span></span><br><span class="line"><span class="keyword">const</span> user1 = UserDirector(<span class="string">'小明'</span>, <span class="number">1</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(user1) <span class="comment">// &#123;name: "小明", gender: "男", age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用结合链式调用的创建者模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个用户类（建造者类）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserBuilder</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户类上添加方法</span></span><br><span class="line">UserBuilder.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">UserBuilder.prototype.setGender = <span class="function"><span class="keyword">function</span> (<span class="params">gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(<span class="built_in">parseInt</span>(gender)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'男'</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'女'</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">this</span>.gender = <span class="string">'未知'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">UserBuilder.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用（在这里产品也充当了指挥者的角色，自行选配需要的对象）</span></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> UserBuilder()</span><br><span class="line">  .setName(<span class="string">'小明'</span>)</span><br><span class="line">  .setAge(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user1) <span class="comment">// &#123;name: "小明", age: 20&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="代理（Proxy）模式"><a href="#代理（Proxy）模式" class="headerlink" title="代理（Proxy）模式"></a>代理（Proxy）模式</h2><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
<p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。</p>
<p>在设计代理对象时，需要<strong>考虑代理接口和本体接口的一致性</strong>。</p>
<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明有一个接电话的方法</span></span><br><span class="line"><span class="keyword">const</span> xiaoming = &#123;</span><br><span class="line">  acceptCall: <span class="function"><span class="keyword">function</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`成功接听电话"<span class="subst">$&#123;phoneNumber&#125;</span>"`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理人代理了小明的电话</span></span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  acceptCall: <span class="function"><span class="keyword">function</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    xiaoming.acceptCall(phoneNumber)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy.acceptCall(<span class="string">'10010'</span>) <span class="comment">// 成功接听电话"10010"</span></span><br></pre></td></tr></table></figure>
<h3 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h3><p>保护代理即代理对象会帮目标对象过滤掉一部分请求的代理模式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明有一个接电话的方法</span></span><br><span class="line"><span class="keyword">const</span> xiaoming = &#123;</span><br><span class="line">  acceptCall: <span class="function"><span class="keyword">function</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`成功接听电话"<span class="subst">$&#123;phoneNumber&#125;</span>"`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理人代理了小明的电话，判断来电如果不在黑名单内就把来电转接给小明</span></span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  acceptCall: <span class="function"><span class="keyword">function</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> blacklist = [<span class="string">'10086'</span>]</span><br><span class="line">    <span class="keyword">if</span> (blacklist.includes(phoneNumber)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`电话"<span class="subst">$&#123;phoneNumber&#125;</span>"在黑名单中，拒绝接听!`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      xiaoming.acceptCall(phoneNumber)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proxy.acceptCall(<span class="string">'10086'</span>) <span class="comment">// 电话"10086"在黑名单中，拒绝接听!</span></span><br><span class="line">proxy.acceptCall(<span class="string">'10010'</span>) <span class="comment">// 成功接听电话"10010"</span></span><br></pre></td></tr></table></figure>
<h3 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h3><p>虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。</p>
<p>下面的示例在DOM树中创建了一个图片节点，通过代理对象在图片节点引用的图片资源没有加载完成时展示一张loading图片。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    myImage.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      myImage.setSrc(<span class="string">'file:///C:/Users/svenzeng/Desktop/loading.gif'</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.setSrc(<span class="string">'&lt;http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 《JavaScript设计模式与开发实践》</span></span><br></pre></td></tr></table></figure>
<p>如果不使用虚拟代理来实现以上方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    imgNode.src = img.src;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = <span class="string">'file:///C:/Users/svenzeng/Desktop/loading.gif'</span>;</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">MyImage.setSrc(<span class="string">'&lt;http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 《JavaScript设计模式与开发实践》</span></span><br></pre></td></tr></table></figure>
<p>这样虽然可以实现功能，但是违反了面向对象设计的原则：<strong>单一职责原则</strong>。</p>
<blockquote>
<p>单一职责原则指的是，就一个类(通常也包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p>
</blockquote>
<p>上段代码中的 MyImage 对象除了负责给 img 节点设置 src 外，还要负责预加载图片。如果我们只是从网络上获取一些体积很小的图片，或者 5 年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从 MyImage 对象里删掉。这时候就不得不改动 MyImage 对象了。</p>
<p>上述虚拟代理示例中实现的代理对象 <code>proxyImage</code> 与本体对象 <code>myImage</code> 都接收 <code>src</code> 属性且都对外提供了 <code>setSrc</code> 方法，在客户看来，代理对象和本体是一致的，保证了代理接口和本体接口的一致性。</p>
<h3 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h3><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参 数跟之前一致，则可以直接返回前面存储的运算结果。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义一个计算乘积的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始计算乘积'</span>)</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    a *= <span class="built_in">arguments</span>[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 输出：开始计算乘积</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在加入缓存代理函数</span></span><br><span class="line"><span class="keyword">const</span> proxyMult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>, <span class="string">','</span>)</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[args]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[args] = mult.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">proxyMult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 输出：开始计算乘积</span></span><br><span class="line">proxyMult(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>缓存代理可以用于缓存ajax异步请求的数据，如分页数据等。</p>
<h3 id="ES6中的Proxy"><a href="#ES6中的Proxy" class="headerlink" title="ES6中的Proxy"></a>ES6中的Proxy</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy对象</a>用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<p>使用 <code>new</code> 运算符创建一个 <code>Proxy</code> 对象，接收一个要包装的目标对象 <code>target</code> 参数，一个定义执行各种操作时代理行为的对象 <code>handler</code> 参数，<code>handler</code> 对象是一个容纳一批特定属性的占位符对象，包含所有捕捉器方法，如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p>
<p><code>handler</code> 对象包含如 <code>get</code> 、<code>set</code> 、<code>apply</code> …… 等多个捕捉器，分别对应不同的代理行为。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, propkey, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'getting: '</span>, propkey)</span><br><span class="line">		<span class="built_in">console</span>.log(proxy === receiver) <span class="comment">// receiver 代表 Proxy 或者继承Proxy的对象，通常是 proxy 本身</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span> <span class="comment">// 访问 target 下面的所有属性均返回 123</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, propkey, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setting: '</span>, propkey)</span><br><span class="line">    target[propkey] = value <span class="comment">// 将 target 下面的所有属性均设置为传入的 value 值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// set() 方法应当返回一个布尔值，返回 true 表示属性设置成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// setting: b</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.b)</span><br><span class="line"><span class="comment">// getting: b</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>利用 <code>Proxy</code> 的特性实现一个简易的数据视图双向绑定。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  set(target, propKey, value) &#123;</span><br><span class="line">    <span class="keyword">let</span> dom = <span class="built_in">document</span>.getElementById(propKey)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dom) &#123;</span><br><span class="line">      dom.innerHTML = value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">      dom.setAttribute(<span class="string">'id'</span>, propKey)</span><br><span class="line">      dom.innerHTML = value</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).appendChild(dom)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.test1 = <span class="string">'测试文字1'</span></span><br><span class="line">proxy.test2 = <span class="string">'测试文字2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">1</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  proxy.test = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;span&gt;测试文字：&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span style="font-size: 36px; font-weight: 900;"&gt;<span class="subst">$&#123;number&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  number++</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>handler.apply()</code> 方法用于拦截函数的调用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">target</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  apply(target, ctx, args) &#123; <span class="comment">// ctx 为被调用时的上下文对象，args 为被调用时的参数数组</span></span><br><span class="line">    <span class="keyword">let</span> [a, b] = args</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h2 id="适配器（Adapter）模式"><a href="#适配器（Adapter）模式" class="headerlink" title="适配器（Adapter）模式"></a>适配器（Adapter）模式</h2><p>适配器的别名是包装器(wrapper)，它的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。</p>
<p>如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种 “亡羊补牢”的模式，没有人会在程序的设计之初就使用它。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们要实现一个渲染地图的功能，我们有如下格式的一组城市数据：</span></span><br><span class="line"><span class="keyword">const</span> cityData = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'beijing'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    name: <span class="string">'shanghai'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时我们有一个渲染地图的方法，但是上面的城市数据的格式不符合渲染地图方法所需的数据格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderMap</span>(<span class="params">cityData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 开始渲染地图</span></span><br><span class="line">  <span class="built_in">console</span>.log(cityData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们定义一个适配器模式的方法来将数据做一个转换</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cityAdapter</span>(<span class="params">oldCityData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cityData = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> city <span class="keyword">of</span> oldCityData) &#123;</span><br><span class="line">    cityData[city.name] = city.id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cityData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">renderMap(cityAdapter(cityData)) <span class="comment">// &#123;beijing: 1, shanghai: 2&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="桥接（Bridge）模式"><a href="#桥接（Bridge）模式" class="headerlink" title="桥接（Bridge）模式"></a>桥接（Bridge）模式</h2><p><strong>桥接模式</strong>（Bridge）将抽象部分与实现部分解耦，使它们都可以独立地变化。同时如果系统沿着多个维度变化时，可以使用桥接模式降低抽象和实现两个可变维度的耦合度。</p>
<p>先来看一个不使用桥接模式点击修改页面文字颜色及字号的示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorDiv = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用桥接模式，实现部分与抽象部分深度耦合</span></span><br><span class="line">colorDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	e.target.style.color = <span class="string">'orange'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用桥接模式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorDiv = <span class="built_in">document</span>.getElementById(<span class="string">'color'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStyle</span>(<span class="params">el, type, fn</span>) </span>&#123; <span class="comment">// 实现部分（这里我们把实现部分也做了抽象化，使之可以通过传入不同"type"实现鼠标点击、移入等多种操作）</span></span><br><span class="line">  el[type] = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStyle</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 抽象部分</span></span><br><span class="line">  <span class="keyword">this</span>.style.color = <span class="string">'orange'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeStyle(colorDiv, <span class="string">'onclick'</span>, setStyle)</span><br></pre></td></tr></table></figure>
<p>使用桥接模式后，增加了代码复杂度（缺点），但是将抽象部分与实现部分解耦，使其可以独立变化。</p>
<p>再看一个组装电脑的示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(level) &#123;</span><br><span class="line">    <span class="keyword">this</span>.level = level</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.level&#125;</span>cpu开始工作`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAM</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(level) &#123;</span><br><span class="line">    <span class="keyword">this</span>.level = level</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.level&#125;</span>内存开始工作`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cpuLevel, ramLevel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpu = <span class="keyword">new</span> CPU(cpuLevel)</span><br><span class="line">    <span class="keyword">this</span>.ram = <span class="keyword">new</span> RAM(ramLevel)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpu.run()</span><br><span class="line">    <span class="keyword">this</span>.ram.run()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computer = <span class="keyword">new</span> Computer(<span class="string">'i7'</span>, <span class="string">'32G'</span>)</span><br><span class="line">computer.run()</span><br></pre></td></tr></table></figure>
<p>这个示例包含CPU与RAM两个维度，我们通过桥接模式快速组合不同配置的CPU与RAM，降低了两个维度（CPU、RAM）与实现部分（组装电脑）的耦合度，使其可以独立变化。</p>
<h2 id="装饰者（Decorator）模式"><a href="#装饰者（Decorator）模式" class="headerlink" title="装饰者（Decorator）模式"></a>装饰者（Decorator）模式</h2><p>在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责，那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。</p>
<p>装饰者模式通常可以应用在例如数据统计上报、插件式的表单验证等用途。</p>
<h3 id="装饰者模式的简单实现"><a href="#装饰者模式的简单实现" class="headerlink" title="装饰者模式的简单实现"></a>装饰者模式的简单实现</h3><p>例如，现在有一个需求要我们生产一辆红色的汽车：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'生产了一辆汽车'</span>)</span><br><span class="line">    <span class="keyword">this</span>.setRedColor()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRedColor() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'将汽车设置为红色'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car()</span><br><span class="line">car.init()</span><br><span class="line"><span class="comment">// 生产了一辆汽车</span></span><br><span class="line"><span class="comment">// 将汽车设置为红色</span></span><br></pre></td></tr></table></figure>
<p>如果后期需求变动为生产一辆蓝色的汽车，代码可能会变成这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'生产了一辆汽车'</span>)</span><br><span class="line">    <span class="keyword">this</span>.setBlueColor()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRedColor() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'将汽车设置为红色'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setBlueColor() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'将汽车设置为蓝色'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car()</span><br><span class="line">car.init()</span><br><span class="line"><span class="comment">// 生产了一辆汽车</span></span><br><span class="line"><span class="comment">// 将汽车设置为蓝色</span></span><br></pre></td></tr></table></figure>
<p>如果后期需求再变动为其他颜色，或者添加一个除颜色之外的其他属性时，生产不同的汽车就变得难以应对。</p>
<p>所以下面用装饰者模式来优化：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'生产了一辆汽车'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">setRedColor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(car) &#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.car.init()</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'将汽车设置为红色'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">setLight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(car) &#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.car.init()</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">'给汽车设置灯光'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> Car()</span><br><span class="line">car = <span class="keyword">new</span> setRedColor(car)</span><br><span class="line">car = <span class="keyword">new</span> setLight(car)</span><br><span class="line">car.init()</span><br><span class="line"><span class="comment">// 生产了一辆汽车</span></span><br><span class="line"><span class="comment">// 将汽车设置为红色</span></span><br><span class="line"><span class="comment">// 给汽车设置灯光</span></span><br></pre></td></tr></table></figure>
<p>优化后的代码使用了给对象动态添加职责的方式（设置颜色），并没有真正地改动对象自身（生产汽车），而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（ <code>init</code> 方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。</p>
<p>因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。</p>
<h3 id="用-AOP-装饰函数"><a href="#用-AOP-装饰函数" class="headerlink" title="用 AOP 装饰函数"></a>用 <a href="https://zh.m.wikipedia.org/zh-sg/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">AOP</a> 装饰函数</h3><p>例如现在有一个关机方法 <code>shutdown</code> ：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shutdown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'正在关机…'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们需要扩展该方法，在调用关机操作后输出关机时间。此时最简单粗暴的方法就是直接改写 <code>shutdown</code> 方法，但这样修改了原方法，不是很好的实现方式。于是我们用通过保存原方法的引用来扩展这个方法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shutdown</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'正在关机…'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _shutdown = shutdown</span><br><span class="line">shutdown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _shutdown()</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">`关机时间：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shutdown()</span><br><span class="line"><span class="comment">// 正在关机…</span></span><br><span class="line"><span class="comment">// 关机时间：2022/1/1 00:10:00</span></span><br></pre></td></tr></table></figure>
<p>这样做使我们在增加新功能的时候没有修改原来的方法，但是这种方式依然存在两个问题：</p>
<ol>
<li>多了一个需要维护的 <code>_shutdown</code> 变量 ，如果函数的装饰链较长或者需要装饰的函数变多，类似的变量也会变得更多。</li>
<li>会有 <code>this</code> 指向被劫持的情况。</li>
</ol>
<p>所以这时我们用 <code>AOP</code> （面向切面编程 Aspect Oriented Programming）装饰函数来重新装饰该方法。</p>
<p><code>AOP</code> 最常用的两种实现方式分别是切入到方法前和切入到方法后，下面看下实现代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = _this.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法都接收一个函数作为参数，然后返回一个“代理”函数。利用 <code>apply</code> 方法确保 <code>this</code> 指向不被劫持，分别在原方法执行前后插入传入的自定义函数，并保证返回原函数一样的结果。</p>
<p>上面的 <code>AOP</code> 装饰函数是将两个方法分别挂载到 <code>Function</code> 的原型上来实现的，如果你不想用这种污染原型的方式，可以将原函数和新函数都作为参数传入两个方法中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params">fn, beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">fn, afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后用两种方法分别来装饰 <code>shutdown</code> 方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> beforeShutdown = shutdown.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">`关机时间：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> afterShutdown = shutdown.after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">`关机时间：<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">beforeShutdown()</span><br><span class="line"><span class="comment">// 关机时间：2022/1/1 00:10:00</span></span><br><span class="line"><span class="comment">// 正在关机…</span></span><br><span class="line"></span><br><span class="line">afterShutdown()</span><br><span class="line"><span class="comment">// 正在关机…</span></span><br><span class="line"><span class="comment">// 关机时间：2022/1/1 00:10:00</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>AOP</code> 装饰函数有两个主要的特性：</p>
<ol>
<li>可以使我们在不改动原函数的情况下将新函数插入到原函数中生成新的方法。</li>
<li>可以动态的改变函数的参数（因为在实现逻辑中，原函数与新函数共享 <code>arguments</code> 参数，所以给了我们改变参数的能力）。</li>
</ol>
<h3 id="装饰模式与代理模式的区别"><a href="#装饰模式与代理模式的区别" class="headerlink" title="装饰模式与代理模式的区别"></a>装饰模式与代理模式的区别</h3><blockquote>
<p>代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代 理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理 - 本体的引用，而装饰者模式经常会形成一条长长的装饰链。 –《JavaScript设计模式与开发实践》</p>
</blockquote>
<h2 id="外观（Facade）模式"><a href="#外观（Facade）模式" class="headerlink" title="外观（Facade）模式"></a>外观（Facade）模式</h2><p><strong>外观模式</strong>（Facade）也叫门面模式，它为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是<strong>封装交互，简化调用</strong>。</p>
<p>例如我们要封装一个给元素添加事件的方法，就可以用外观模式来做跨浏览器的兼容方案。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">el, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.addEventListener) &#123;</span><br><span class="line">    el.addEventListener(type, fn, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.attachEvent) &#123; <span class="comment">// &lt; IE9（IE5-IE10支持 attachEvent）</span></span><br><span class="line">    el.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el[<span class="string">'on'</span> + type] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">addEvent(<span class="built_in">document</span>.getElementById(<span class="string">'div'</span>), <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dom = e.target || e.srcElement;</span><br><span class="line">  dom.style.color = <span class="string">'orange'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="享元（Flyweight）模式"><a href="#享元（Flyweight）模式" class="headerlink" title="享元（Flyweight）模式"></a>享元（Flyweight）模式</h2><p>享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。</p>
<p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。</p>
<p>先看一个例子：</p>
<p>假设有一家服装工厂，目前的产品有50种男性服装+50种女性服装，现在要分别为这100种服装拍照，工厂决定生产塑料模特来穿上服装拍照。</p>
<p>在不使用享元模式的情况下，需要生产100个塑料模特（100个model对象），代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sex, underwear) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">    <span class="keyword">this</span>.underwear = underwear</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  takePhoto() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`TakePhoto <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>, underwear <span class="subst">$&#123;<span class="keyword">this</span>.underwear&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> maleModel = <span class="keyword">new</span> Model(<span class="string">'male'</span>, i)</span><br><span class="line">  maleModel.takePhoto()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> femaleModel = <span class="keyword">new</span> Model(<span class="string">'female'</span>, i)</span><br><span class="line">  femaleModel.takePhoto()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要得到一张照片，每次都需要传入 <code>sex</code> 和 <code>underwear</code> 两个参数，共创建了100个model对象。很显然实际并不需要生产100个塑料模特，只需要生产两个（一个男性一个女性）分别拍照即可。</p>
<p>改写代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sex) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  takePhoto(underwear) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`TakePhoto <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>, underwear <span class="subst">$&#123;underwear&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maleModel = <span class="keyword">new</span> Model(<span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  maleModel.takePhoto(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> femaleModel = <span class="keyword">new</span> Model(<span class="string">'female'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">  femaleModel.takePhoto(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改写后的代码只生产了2个model对象，创建对象时只传入 <code>sex</code> 属性，<code>underwear</code> 则被抽离成外部参数，调用 <code>takePhoto</code> 方法时才传入使用。</p>
<p>上面的例子即是享元模式的雏形，享元模式要求将对象的属性划分为<strong>内部状态</strong>与<strong>外部状态</strong>（状态在这里通常指属性），例子中的内部状态为 <code>sex</code> ，外部状态为 <code>underwear</code> 。享元模式的目标是尽量减少共享对象的数量。</p>
<p>关于如何划分<strong>内部状态</strong>和<strong>外部状态</strong>：</p>
<ol>
<li>内部状态存储于对象内部。</li>
<li>内部状态可以被一些对象共享。</li>
<li>内部状态独立于具体的场景，通常不会改变。</li>
<li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li>
</ol>
<p>在上面的例子中，不使用享元模式时，我们需要将所有状态（可以共享+不可共享）的组合组成一个个独立的对象，这在多个状态的情况下是不可行的，因为可能会组合出数量非常庞大的独立对象，所占用的内存也是非常大的。这时就可以使用享元模式来进行优化：剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，<strong>享元模式是一种用时间换空间的优化模式</strong>。</p>
<h2 id="组合（Composite）模式"><a href="#组合（Composite）模式" class="headerlink" title="组合（Composite）模式"></a>组合（Composite）模式</h2><p>组合模式将对象组合成树形结构，以表示“部分 - 整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>在组合模式中，请求在树中传递的过程总是遵循一种逻辑。如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。</p>
<h3 id="组合模式示例"><a href="#组合模式示例" class="headerlink" title="组合模式示例"></a>组合模式示例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.fileList = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fileList.push(file)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`开始读取文件夹: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileList.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>: &lt;空&gt;`</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="keyword">this</span>.fileList[i]; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fileList[i].read()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	add() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'叶对象不能添加子节点'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`开始读取文件: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folder = <span class="keyword">new</span> Folder(<span class="string">'folder'</span>)</span><br><span class="line"><span class="keyword">const</span> folder1 = <span class="keyword">new</span> Folder(<span class="string">'folder1'</span>)</span><br><span class="line"><span class="keyword">const</span> folder2 = <span class="keyword">new</span> Folder(<span class="string">'folder2'</span>)</span><br><span class="line"><span class="keyword">const</span> file1 = <span class="keyword">new</span> File(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> file2 = <span class="keyword">new</span> File(<span class="string">'file2'</span>)</span><br><span class="line"><span class="keyword">const</span> file3 = <span class="keyword">new</span> File(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line">folder.add(folder1)</span><br><span class="line">folder1.add(file1)</span><br><span class="line">folder1.add(file2)</span><br><span class="line">folder1.add(folder2)</span><br><span class="line">folder.add(file3)</span><br><span class="line"></span><br><span class="line">folder.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 开始读取文件夹: folder</span></span><br><span class="line"><span class="comment">// 开始读取文件夹: folder1</span></span><br><span class="line"><span class="comment">// 开始读取文件: file1</span></span><br><span class="line"><span class="comment">// 开始读取文件: file2</span></span><br><span class="line"><span class="comment">// 开始读取文件夹: folder2</span></span><br><span class="line"><span class="comment">// folder2: &lt;空&gt;</span></span><br><span class="line"><span class="comment">// 开始读取文件: file3</span></span><br></pre></td></tr></table></figure>
<p>以上示例包含 <code>Folder</code> 和 <code>File</code> 两个类，分别代表文件夹和文件。他们都有 <code>name</code> 属性表示自己的名称，文件夹有一个 <code>fileList</code> 属性用来存储自己内部的文件。两者都提供了 <code>read</code> 读取方法，文件夹的读取方法表示读取自己内部的文件，而文件的 <code>read</code> 方法用来读取自身。文件夹还提供了一个 <code>add</code> 方法用来将文件添加到自己的文件列表内。</p>
<p>文件和文件夹之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树。当调用 <code>folder.read()</code> 方法时，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象，组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。</p>
<h3 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h3><ul>
<li><p>组合模式不是父子关系</p>
<p>  组合模式是一种聚合的关系。组合对象包含一组叶对象，但叶对象并不是组合对象的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口，但实际上它们并非真正意义上的父子关系。</p>
</li>
<li><p>对叶对象操作的一致性</p>
<p>  只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。</p>
</li>
<li><p>双向映射关系</p>
<p>  某些情况下叶对象可能从属于多个组合对象，或者叶对象某些功能的实现需要依赖组合对象，这时我们需要给组合对象与叶对象建立双向映射的关系来实现某些功能（如下面删除文件/文件夹的功能）。</p>
</li>
</ul>
<h3 id="建立双向映射关系"><a href="#建立双向映射关系" class="headerlink" title="建立双向映射关系"></a>建立双向映射关系</h3><p>如果这时要给文件/文件夹添加删除方法，在调用时实际上是从这个文件/文件夹所在的上层文件夹中删除的，所以此时组合对象与叶对象之间建立双向映射关系就是必要的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.fileList = []</span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(file) &#123;</span><br><span class="line">    file.parent = <span class="keyword">this</span> <span class="comment">// 设置父对象</span></span><br><span class="line">    <span class="keyword">this</span>.fileList.push(file)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`开始读取文件夹: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileList.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>: &lt;空&gt;`</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="keyword">this</span>.fileList[i]; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fileList[i].read()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) &#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parent.fileList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> file = <span class="keyword">this</span>.parent.fileList[i]</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`删除文件夹: <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">this</span>.parent.fileList.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	add() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'叶对象不能添加子节点'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  read() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`开始读取文件: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.parent) &#123; <span class="comment">// 根节点或者树外的游离节点</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parent.fileList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> file = <span class="keyword">this</span>.parent.fileList[i]</span><br><span class="line">      <span class="keyword">if</span> (file === <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`删除文件: <span class="subst">$&#123;file.name&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">this</span>.parent.fileList.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folder = <span class="keyword">new</span> Folder(<span class="string">'folder'</span>)</span><br><span class="line"><span class="keyword">const</span> folder1 = <span class="keyword">new</span> Folder(<span class="string">'folder1'</span>)</span><br><span class="line"><span class="keyword">const</span> folder2 = <span class="keyword">new</span> Folder(<span class="string">'folder2'</span>)</span><br><span class="line"><span class="keyword">const</span> file1 = <span class="keyword">new</span> File(<span class="string">'file1'</span>)</span><br><span class="line"><span class="keyword">const</span> file2 = <span class="keyword">new</span> File(<span class="string">'file2'</span>)</span><br><span class="line"><span class="keyword">const</span> file3 = <span class="keyword">new</span> File(<span class="string">'file3'</span>)</span><br><span class="line"></span><br><span class="line">folder.add(folder1)</span><br><span class="line">folder1.add(file1)</span><br><span class="line">folder1.add(file2)</span><br><span class="line">folder1.add(folder2)</span><br><span class="line">folder.add(file3)</span><br><span class="line"></span><br><span class="line">folder2.remove()</span><br><span class="line">file2.remove()</span><br><span class="line">folder.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 删除文件夹: folder2</span></span><br><span class="line"><span class="comment">// 删除文件: file2</span></span><br><span class="line"><span class="comment">// 开始读取文件夹: folder</span></span><br><span class="line"><span class="comment">// 开始读取文件夹: folder1</span></span><br><span class="line"><span class="comment">// 开始读取文件: file1</span></span><br><span class="line"><span class="comment">// 开始读取文件: file3</span></span><br></pre></td></tr></table></figure>
<p>以上代码给文件夹和文件类中分别加入了一个 <code>parent</code> 属性来保存其父文件夹的引用，又为它们各自添加了一个 <code>remove</code> 方法用来删除自身。当它们被某个文件夹调用 <code>add</code> 方法添加时，会把自己的 <code>parent</code> 属性指向该文件夹，这样调用自己的 <code>remove</code> 方法时就可以遍历自己父文件夹的文件列表，找到自身后将其移除。</p>
<h3 id="何时使用组合模式"><a href="#何时使用组合模式" class="headerlink" title="何时使用组合模式"></a>何时使用组合模式</h3><p>组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况：</p>
<ol>
<li>表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 式中增加和删除树的节点非常方便，并且符合开放-封闭原则。</li>
<li>客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。</li>
</ol>
<p><em>《JavaScript设计模式与开发实践》</em></p>
<h2 id="模板方法（Template-Method）模式"><a href="#模板方法（Template-Method）模式" class="headerlink" title="模板方法（Template Method）模式"></a>模板方法（Template Method）模式</h2><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类。</p>
<h3 id="模板方法示例"><a href="#模板方法示例" class="headerlink" title="模板方法示例"></a>模板方法示例</h3><p>假如我们现在要冲泡一杯咖啡，有如下四个步骤：</p>
<ol>
<li>把水煮沸</li>
<li>用沸水冲泡咖啡</li>
<li>把咖啡倒进杯子</li>
<li>加牛奶</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">  boilWater() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  brew() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pourInCup() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addMilk() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加牛奶'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.brew()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">this</span>.addMilk()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> Coffee()</span><br><span class="line">coffee.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line"><span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line"><span class="comment">// 加牛奶</span></span><br></pre></td></tr></table></figure>
<p>如果现在又要冲泡一杯柠檬茶，也有四个步骤：</p>
<ol>
<li>把水煮沸</li>
<li>用沸水冲泡茶叶</li>
<li>把茶水倒进杯子</li>
<li>加柠檬</li>
</ol>
<p>冲咖啡与冲茶步骤类似，主要的制作区别在第2步与第4步。所以这时我们可以使用模板方法模式，来创建一个 <code>Beverage</code> 类来指代饮料，分别用继承的方式创建 <code>Coffee</code> 与 <code>Tea</code> 用作冲泡咖啡与茶。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  boilWater() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  brew() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子类必须重写 brew 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pourInCup() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'倒进杯子'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addCondiment() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子类必须重写 addCondiment 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 钩子方法</span></span><br><span class="line">  isNeedCondiment() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.brew()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isNeedCondiment()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addCondiment()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  brew() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addCondiment() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加牛奶'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isNeedCondiment() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  brew() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡茶叶'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addCondiment() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加柠檬'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isNeedCondiment() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> Coffee()</span><br><span class="line">coffee.init()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tea = <span class="keyword">new</span> Tea()</span><br><span class="line">tea.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line"><span class="comment">// 倒进杯子</span></span><br><span class="line"><span class="comment">// 加牛奶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡茶叶</span></span><br><span class="line"><span class="comment">// 倒进杯子</span></span><br><span class="line"><span class="comment">// 加柠檬</span></span><br></pre></td></tr></table></figure>
<p>上面的代码我们首先创建了一个抽象类 <code>Beverage</code> ，该类中的前四个方法提供了制作饮料需要的四个步骤。其中 <code>brew</code> 和 <code>addCondiment</code> 方法为抽象方法，继承的子类必须提供对应的方法来覆盖（如果需要加调料的话），否则会抛错提醒。<code>boilWater</code> 和 <code>pourInCup</code> 方法继承的子类可以提供以覆盖默认行为或者不提供。同时我们还新增了一个钩子方法 <code>isNeedCondiment</code> 来让子类选择是否添加调料，默认行为是不添加。</p>
<p>让我们来统计一下上面代码中出现的各种类和方法：</p>
<p>抽象类：<code>Beverage</code></p>
<p>抽象方法：<code>brew</code> 、<code>addCondiment</code></p>
<p>具体类：<code>Coffee</code>、<code>Tea</code></p>
<p>具体方法：<code>boilWater</code> 、<code>pourInCup</code></p>
<p>钩子方法（hook）：<code>isNeedCondiment</code></p>
<p>模板方法：<code>init</code></p>
<p>最终，我们调用模板方法 <code>init</code> 来制作了两杯饮料（咖啡和柠檬茶）。这个方法规定了子类的算法和框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。</p>
<p>在传统面向对象的语言中（如Java），我们可以创建不能被实例化的抽象类，用于规定实现子类的框架和算法，这个抽象类一定是用来被某些具体类继承的。而在JavaScript中，没有抽象类的概念，所以我们用以上的形式模拟抽象类的实现，也能达到相应的目的。</p>
<p>在JavaScript中，我们很多时候都不需要依样画瓢（使用抽象类与继承）地去实现一个模版方法模式，高阶函数是更好的选择。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> brew = param.brew || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 brew 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'倒进杯子'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addCondiment = param.addCondiment || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 addCondiment 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    boilWater()</span><br><span class="line">    brew()</span><br><span class="line">    pourInCup()</span><br><span class="line">    addCondiment()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Tea = Beverage(&#123;</span><br><span class="line">  brew() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡茶叶'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  addCondiment() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加柠檬'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tea = <span class="keyword">new</span> Tea()</span><br><span class="line">tea.init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把水煮沸</span></span><br><span class="line"><span class="comment">// 用沸水冲泡茶叶</span></span><br><span class="line"><span class="comment">// 倒进杯子</span></span><br><span class="line"><span class="comment">// 加柠檬</span></span><br></pre></td></tr></table></figure>
<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><blockquote>
<p>“不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)”这是著名的好莱坞原则。在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项的完全控制，演员只能被动式的接受公司的差使，在需要的环节中，完成自己的演出。</p>
</blockquote>
<p>模板方法模式是好莱坞原则的一个典型使用场景。用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。</p>
<p>除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。</p>
<h2 id="解释器（Interpreter）模式"><a href="#解释器（Interpreter）模式" class="headerlink" title="解释器（Interpreter）模式"></a>解释器（Interpreter）模式</h2><p>定义：<strong>给定一个语言，定义它的文法的一种表示，并定义一个解释器。这个解释器使用该表示来解释语言中的句子。</strong></p>
<p>日常见到的解释器：</p>
<p>正则表达式：它就是解释器模式的一种应用，解释器会根据正则表达式的固定文法，去对一个正则表达式进行解释。</p>
<p>代码解释器：负责解释并执行代码逻辑。（注意：这里代码解释器与编译器有所不同，解释器不会对代码进行编译转换，仅仅是解释执行，而编译器会把源文件转换成另外一种形式的代码，不会执行代码逻辑）</p>
<p>日常开发中基本不会用到解释器模式。</p>
<p>解释器模式通常由 AbstractExpression （抽象语法表达式）、TerminalExpression （终结符）与NonterminalExpression （非终结符）组成。</p>
<p>调用时遇到非终结符则继续调用，只有终结符才能直接判断。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类，终结符与非终结符都继承自该类并实现各自的 interpret 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">  interpret() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(values) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.values = values <span class="comment">// 计算范围Array</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interpret(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.values.includes(value) <span class="comment">// 值必须在values范围内包含</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(left, right) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.right = right</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  interpret(value) &#123;</span><br><span class="line">    value = value.replace(<span class="regexp">/\s*/g</span>, <span class="string">''</span>) <span class="comment">// 去除字符串内所有空格</span></span><br><span class="line">    <span class="keyword">if</span> (!value.includes(<span class="string">'+'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须包含+号'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [value1, value2] = value.split(<span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.left.interpret(value1) &amp;&amp; <span class="keyword">this</span>.right.interpret(value2)</span><br><span class="line">      ? <span class="built_in">Number</span>(value1) + <span class="built_in">Number</span>(value2)</span><br><span class="line">      : <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'参数不在计算范围内'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> range = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>] <span class="comment">// 计算参数范围</span></span><br><span class="line"><span class="keyword">const</span> terminal = <span class="keyword">new</span> TerminalExpression(range)</span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> NonterminalExpression(terminal, terminal)</span><br><span class="line"></span><br><span class="line">add.interpret(<span class="string">'3 + 5'</span>) <span class="comment">// 8</span></span><br><span class="line">add.interpret(<span class="string">'2 + 10'</span>) <span class="comment">// 12</span></span><br><span class="line">add.interpret(<span class="string">'3 - 1'</span>) <span class="comment">// Error: 必须包含"+"号</span></span><br><span class="line">add.interpret(<span class="string">'3 + 11'</span>) <span class="comment">// Error: 参数不在计算范围内</span></span><br></pre></td></tr></table></figure>
<p>解释器将复杂语法解析抽象为一个个独立的终结符与非终结符各自判断，只要每个文法自己的判断做好了，剩下的工作就是组装文法。</p>
<p>这种将单个逻辑判断与文法组装解耦的做法，可以使逻辑判断与文法组装独立变换，使复杂语法解析转化为一个个具体的简单问题。</p>
<p>上述代码只是对单一示例的简单实现，实际上在实现一个解释器的时候，往往会涉及到编译原理相关的知识。</p>
<h2 id="策略（Strategy）模式"><a href="#策略（Strategy）模式" class="headerlink" title="策略（Strategy）模式"></a>策略（Strategy）模式</h2><p>策略模式指的是<strong>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换</strong>。</p>
<blockquote>
<p>“并且使它们可以相互替换”，这句话在很大程度上是相对于静态类型语言而言的。因为静态类型语言中有类型检查机制，所以各个策略类需要实现同样的接口。当它们的真正类型被隐藏在接口后面时，它们才能被相互替换。而在 JavaScript 这种“类型模糊”的语言中没有这种困扰，任何对象都可以被替换使用。因此，JavaScript 中的“可以相互替换使用”表现为它们具有相同的目标和意图。</p>
</blockquote>
<p>假如我们需要实现一个计算券后价格的方法，该方法通过传入原价与优惠券来计算享受了优惠券折扣后的商品价格。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 <code>Context</code>，<code>Context</code> 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 <code>Context</code> 中要维持对某个策略对象的引用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculatePrice</span>(<span class="params">price, coupon</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (coupon === <span class="string">'A'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.9</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coupon === <span class="string">'B'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (coupon === <span class="string">'C'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.7</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用策略模式重构方法"><a href="#使用策略模式重构方法" class="headerlink" title="使用策略模式重构方法"></a>使用策略模式重构方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponA</span> </span>&#123;</span><br><span class="line">  calculatePrice(price) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.9</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponB</span> </span>&#123;</span><br><span class="line">  calculatePrice(price) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CouponC</span> </span>&#123;</span><br><span class="line">  calculatePrice(price) &#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.price = <span class="literal">null</span> <span class="comment">// 商品原价</span></span><br><span class="line">    <span class="keyword">this</span>.strategy = <span class="literal">null</span> <span class="comment">// 优惠券对应的策略对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPrice(price) &#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setStrategy(strategy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取券后优惠券价格</span></span><br><span class="line">  getDiscountPrice() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculatePrice(<span class="keyword">this</span>.price)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> goods = <span class="keyword">new</span> Goods()</span><br><span class="line">goods.setPrice(<span class="number">10</span>)</span><br><span class="line">goods.setStrategy(<span class="keyword">new</span> CouponB())</span><br><span class="line">goods.getDiscountPrice() <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>以上代码使用了策略模式，定义一系列的算法，把它们各自封装成策略类<code>CouponA</code>、<code>CouponB</code>、<code>CouponC</code> ，算法被封装在策略类内部的方法里。在客户对 <code>Context</code> 发起请求的时候，<code>Context</code> 总是把请求委托给这些策略对象中间的某一个进行计算。</p>
<p>通过策略模式重构之后，代码变得更加清晰，各个类的职责更加鲜明。但这段代码是基于传统面向对象语言的模仿，下面我们用 JavaScript 来实现策略模式。</p>
<h3 id="JavaScript版本的策略模式"><a href="#JavaScript版本的策略模式" class="headerlink" title="JavaScript版本的策略模式"></a>JavaScript版本的策略模式</h3><p>在 JavaScript 中，函数也是对象，所以更简单和直接的做法是把 <code>strategy</code> 直接定义为函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="string">'A'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.9</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'B'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.8</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'C'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price * <span class="number">0.7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculatePrice = <span class="function"><span class="keyword">function</span>(<span class="params">coupon, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[coupon](price)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculatePrice(<span class="string">'A'</span>, <span class="number">10</span>) <span class="comment">// 9</span></span><br><span class="line">calculatePrice(<span class="string">'B'</span>, <span class="number">10</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。</p>
<p>通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算价格有关的逻辑不再放在 <code>Context</code> 中，而是分布在各个策略对象中。<code>Context</code> 并没有计算价格的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算价格”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换 <code>Context</code> 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p>
<p>从定义上看，策略模式就是用来封装算法的。但在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。策略模式一般也会被用来实现表单校验等功能。</p>
<h3 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h3><ul>
<li>优点<ol>
<li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。</li>
<li>策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 <code>strategy</code> 中，使得它们易于切换，易于理解，易于扩展。</li>
<li>策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。</li>
<li>在策略模式中利用组合和委托来让 <code>Context</code> 拥有执行算法的能力，这也是继承的一种更轻<br>便的替代方案。</li>
</ol>
</li>
<li>缺点<ol>
<li>使用策略模式会在程序中增加许多策略类或者策略对象。（但实际上这比把它们负责的逻辑堆砌在 <code>Context</code> 中要好）</li>
<li>要使用策略模式，必须了解所有的 <code>strategy</code>，必须了解各个 <code>strategy</code> 之间的不同点，这样才能选择一个合适的 <code>strategy</code>。</li>
</ol>
</li>
</ul>
<h2 id="命令（Command）模式"><a href="#命令（Command）模式" class="headerlink" title="命令（Command）模式"></a>命令（Command）模式</h2><p>命令模式中的命令(command)指的是一个执行某些特定事情的指令。</p>
<p>命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。</p>
<p>下面来看一个具体的实例：现在有2个按钮，我们需要给两个按钮填充对应的功能。绘制按钮与填充功能分别由不同的人进行开发，这时使用命令模式就变得非常合理。绘制按钮的人需要在按钮点击的时候向某些对象发送请求，但是不需要关心请求的接收者是谁，也不需要知道被请求的操作是什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button1 = <span class="built_in">document</span>.getElementById(<span class="string">'button1'</span>)</span><br><span class="line"><span class="keyword">const</span> button2 = <span class="built_in">document</span>.getElementById(<span class="string">'button2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者对象（负责定义安装命令的接口）</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button, command</span>) </span>&#123;</span><br><span class="line">  button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    command.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者对象（负责具体执行）</span></span><br><span class="line"><span class="keyword">const</span> MenuObj = &#123;</span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'刷新页面'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  back: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'后退'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令对象（负责暴露出统一的调用方法给发布者对象，并且去调用接收者对象的命令）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefreshCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver.refresh()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackCommand</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver.back()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> refreshCommand = <span class="keyword">new</span> RefreshCommand(MenuObj)</span><br><span class="line"><span class="keyword">const</span> backCommand = <span class="keyword">new</span> BackCommand(MenuObj)</span><br><span class="line">setCommand(button1, refreshCommand)</span><br><span class="line">setCommand(button2, backCommand)</span><br></pre></td></tr></table></figure>
<p>上面代码使用命令模式为两个按钮分别填充了各自的功能，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。这里使用了3个角色来实现功能：</p>
<ol>
<li><strong>发布者对象</strong>：请求的发起者，不关心接收者是谁，也不知道接收者会做什么，通过命令对象进行调用。</li>
<li><strong>接收者对象</strong>：负责接收与具体执行的对象，拥有执行命令接口。不关心也不知道谁发出的命令。</li>
<li><strong>命令对象</strong>：暴露统一接口给发布者，并且负责去调用接收者接口的对象。充当发布者与接收者之间的桥梁，实现发布者与接收者之间的解耦。</li>
</ol>
<h3 id="JavaScript中的命令模式"><a href="#JavaScript中的命令模式" class="headerlink" title="JavaScript中的命令模式"></a>JavaScript中的命令模式</h3><p>以上代码是模拟传统面向对象语言的命令模式实现。<br>命令模式的由来，其实是回调(callback)函数的一个面向对象的替代品。<br>JavaScript 作为将函数作为一等对象的语言，运算块不一定要封装在 <code>command.execute</code> 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button1 = <span class="built_in">document</span>.getElementById(<span class="string">'button1'</span>)</span><br><span class="line"><span class="keyword">const</span> button2 = <span class="built_in">document</span>.getElementById(<span class="string">'button2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布者对象（负责定义安装命令的接口）</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button, command</span>) </span>&#123;</span><br><span class="line">  button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    command.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者对象（负责具体执行）</span></span><br><span class="line"><span class="keyword">const</span> MenuObj = &#123;</span><br><span class="line">  refresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'刷新页面'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  back: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'后退'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令对象（负责暴露出统一的调用方法给发布者对象，并且去调用接收者对象的命令）</span></span><br><span class="line"><span class="keyword">const</span> RefreshCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="comment">// 这里也可以直接返回函数供发布者对象使用，但是为了将来提供其他操作（如撤销命令等操作），所以返回一个包含操作的对象</span></span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      receiver.refresh()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> BackCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      receiver.back()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> refreshCommand = <span class="keyword">new</span> RefreshCommand(MenuObj)</span><br><span class="line"><span class="keyword">const</span> backCommand = <span class="keyword">new</span> BackCommand(MenuObj)</span><br><span class="line">setCommand(button1, refreshCommand)</span><br><span class="line">setCommand(button2, backCommand)</span><br></pre></td></tr></table></figure>
<h3 id="命令模式实现撤销和重做"><a href="#命令模式实现撤销和重做" class="headerlink" title="命令模式实现撤销和重做"></a>命令模式实现撤销和重做</h3><p>命令对象的作用除了可以给发布者暴露接口和调用接收者对象之外，还可以很方便的记录执行历史，从而实现撤销和重做功能。</p>
<p>下面的代码我将用之前写过的小程序电子签名组件为例，来为其加入撤销和重做功能。</p>
<p>首先是基本的绘制功能，实现原理很简单，只需要在小程序的 canvas 组件中监听手指触摸动作开始 <code>bindtouchstart</code> 和手指触摸后移动 <code>bindtouchmove</code> 两个事件，从回调函数中取到相应的坐标用小程序为我们提供的 Canvas 2D 相关 api 进行绘制即可。这里我们用 <code>Sign</code> 类来封装相关的代码，<code>Sign</code> 类在这里充当的是接收者对象的角色。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 电子签名组件（wxml页面内需要提供id="signCanvas"的canvas画布）</span></span><br><span class="line"><span class="comment"> * 使用方式：</span></span><br><span class="line"><span class="comment"> *   1. const signInstance = new Sign() // 实例化组件</span></span><br><span class="line"><span class="comment"> *   2. signInstance.initCanvas() // 调用组件初始化方法</span></span><br><span class="line"><span class="comment"> *   3. signInstance.draw(config) // 调用绘制方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sign</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.canvas = <span class="literal">null</span>; <span class="comment">// Canvas对象</span></span><br><span class="line">    <span class="keyword">this</span>.ctx = <span class="literal">null</span>; <span class="comment">// Canvas 绘制上下文</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化Canvas画布</span></span><br><span class="line">  initCanvas() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      wx.createSelectorQuery()</span><br><span class="line">        .select(<span class="string">"#signCanvas"</span>)</span><br><span class="line">        .fields(&#123; <span class="attr">node</span>: <span class="literal">true</span>, <span class="attr">size</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        .exec(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.canvas = res[<span class="number">0</span>].node;</span><br><span class="line">          <span class="keyword">this</span>.ctx = <span class="keyword">this</span>.canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">          <span class="keyword">const</span> &#123; canvas, ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">          <span class="keyword">const</span> dpr = wx.getSystemInfoSync().pixelRatio;</span><br><span class="line">          canvas.width = res[<span class="number">0</span>].width * dpr;</span><br><span class="line">          canvas.height = res[<span class="number">0</span>].height * dpr;</span><br><span class="line">          ctx.scale(dpr, dpr);</span><br><span class="line">          <span class="comment">// 设置画布背景色</span></span><br><span class="line">          ctx.fillStyle = <span class="string">"#ffffff"</span>;</span><br><span class="line">          ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 绘制</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.startX 起始x坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.startY 起始y坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.moveX 要移动到的x点坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.moveY 要移动到的y点坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  draw(config = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; startX, startY, moveX, moveY &#125; = config;</span><br><span class="line">    <span class="keyword">if</span> (startX || startY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ctx.moveTo(startX, startY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moveX || moveY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.ctx.lineWidth = <span class="number">2</span>; <span class="comment">// 设置线条宽度</span></span><br><span class="line">      <span class="keyword">this</span>.ctx.lineTo(moveX, moveY);</span><br><span class="line">      <span class="keyword">this</span>.ctx.stroke();</span><br><span class="line">      <span class="keyword">this</span>.ctx.moveTo(moveX, moveY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的接收者对象提供了 <code>initCanvas</code> 方法用来初始化画布，<code>draw</code> 方法用来绘制。</p>
<p>接下来我们实现 <code>SignCommand</code> 类，即命令对象。这个对象里调用了接收者对象 <code>Sign</code> ，并向外部暴露了 <code>execute</code> 执行、撤销 <code>prev</code> 和重做 <code>next</code> 等方法。同时还在自身内部维护了绘制历史 <code>history</code> 对象，这是我们实现撤销和重做功能的关键（因为canvas很难实现上一步的操作，所以这里我们使用保存绘制历史重新绘制的方式实现撤销功能）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signCommand.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Sign <span class="keyword">from</span> <span class="string">"@/utils/sign.js"</span>; <span class="comment">// 电子签名组件（接收者对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电子签名命令对象（命令对象）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SignCommand</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; page 页面this实例</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; receiver 电子签名对象（在这里是接收者对象）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(page, receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.page = page; <span class="comment">// 指向页面this</span></span><br><span class="line">    <span class="keyword">this</span>.receiver = receiver; <span class="comment">// 签名组件实例</span></span><br><span class="line">    <span class="keyword">this</span>.history = []; <span class="comment">// 步骤历史数组</span></span><br><span class="line">    <span class="keyword">this</span>.step = <span class="number">0</span>; <span class="comment">// 当前所在的步骤数</span></span><br><span class="line">    <span class="keyword">this</span>.history_item_cache = []; <span class="comment">// 用来存放每一步历史记录的临时缓存</span></span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 初始化/重置画布</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.receiver.initCanvas();</span><br><span class="line">    <span class="keyword">this</span>.history = [];</span><br><span class="line">    <span class="keyword">this</span>.step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.history_item_cache = [];</span><br><span class="line">    <span class="keyword">this</span>._updatePageStep();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 执行命令（绘制）</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.startX 起始x坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.startY 起始y坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.moveX 要移动到的x点坐标</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; config.moveY 要移动到的y点坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  execute(config = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; touchEnd &#125; = config;</span><br><span class="line">    <span class="keyword">if</span> (touchEnd) &#123;</span><br><span class="line">      <span class="keyword">this</span>.step++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.history_item_cache.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.history_item_cache);</span><br><span class="line">        <span class="keyword">this</span>.history_item_cache = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>._updatePageStep();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.receiver.draw(config);</span><br><span class="line">    <span class="comment">// 将绘画步骤添加到历史记录中并设置为最后一步</span></span><br><span class="line">    <span class="keyword">const</span> &#123; startX, startY, moveX, moveY &#125; = config;</span><br><span class="line">    <span class="keyword">if</span> (startX || startY || moveX || moveY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.history = <span class="keyword">this</span>.history.slice(<span class="number">0</span>, <span class="keyword">this</span>.step);</span><br><span class="line">      <span class="keyword">this</span>.history_item_cache.push(&#123;</span><br><span class="line">        startX,</span><br><span class="line">        startY,</span><br><span class="line">        moveX,</span><br><span class="line">        moveY,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 上一步（撤销）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> prev() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.step === <span class="number">0</span> || <span class="keyword">this</span>.history.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.step--;</span><br><span class="line">    <span class="keyword">this</span>._updatePageStep();</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.receiver.initCanvas();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.step; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.history[i].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.draw(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 下一步（重做）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.step === <span class="keyword">this</span>.history.length) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.step++;</span><br><span class="line">    <span class="keyword">this</span>._updatePageStep();</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.receiver.initCanvas();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.step; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.history[i].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.draw(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 更新页面步骤信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _updatePageStep() &#123;</span><br><span class="line">    <span class="keyword">this</span>.page.setData(&#123;</span><br><span class="line">      currentStep: <span class="keyword">this</span>.step,</span><br><span class="line">      historyLength: <span class="keyword">this</span>.history.length,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @description: 保存签名图片至相册</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  save() &#123;</span><br><span class="line">	  <span class="comment">// 该方法内包含检查用户相册权限、将画布内容转化为图片等功能，不在本次讨论范围内，暂且不占用篇幅列出</span></span><br><span class="line">	  <span class="built_in">console</span>.log(<span class="string">'保存成功'</span>)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们的代码已经实现了撤销和重做的相关功能，只需要在小程序页面里调用即可。这里并没有封装通用的发布者对象，在小程序里每个相应的事件方法都充当了发布者（并非传统意义上的发布者对象，在这里只是起到了执行命令的作用）的角色。</p>
<h2 id="职责链（Chain-of-Responsibility）模式"><a href="#职责链（Chain-of-Responsibility）模式" class="headerlink" title="职责链（Chain of Responsibility）模式"></a>职责链（Chain of Responsibility）模式</h2><p>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>此时我们有3个方法：<code>f1</code> 、<code>f2</code> 、<code>f3</code> ，这3个方法通过接收不同的参数来处理各自的请求。我们想用职责链模式来包装这3个方法，使其能够按照顺序选择处理请求，过程如下：</p>
<p>第1个方法接收到参数后，判断是否该交由自己处理，如果自己可以处理，处理完成并返回结果，如果自己处理不了，交由第2个方法处理（此时我们约定如果自己处理不了则返回一个特定的字符串 <code>nextSuccessor</code> 表示需要往后传递），以此类推。</p>
<p>这3个方法我们暂时省略参数及判断和处理过程。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'nextSuccessor'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'nextSuccessor'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span> <span class="comment">// 表示处理结束，返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们定义职责链包装方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fn = fn <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="keyword">this</span>.successor = <span class="literal">null</span> <span class="comment">// 表示职责链中的下一个节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置职责链中的下一个节点</span></span><br><span class="line">  setNextSuccessor(successor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor = successor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传递请求给某个节点</span></span><br><span class="line">  passRequest() &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply(<span class="keyword">this</span>.successor, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们把3个方法分别包装成职责链的节点并将请求参数传入第一个节点：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Chain(f1), p2 = <span class="keyword">new</span> Chain(f2), p3 = <span class="keyword">new</span> Chain(f3) <span class="comment">// 用职责链模式包装</span></span><br><span class="line">p1.setNextSuccessor(p2).setNextSuccessor(p3) <span class="comment">// 指定职责链中节点的下一个节点</span></span><br><span class="line"></span><br><span class="line">p1.passRequest(params) <span class="comment">// done</span></span><br><span class="line"><span class="comment">// 这里我们的3个方法省略了内部的判断及处理过程，返回结果总是固定的，实际上是会在方法内部对传入的params进行判断处理</span></span><br></pre></td></tr></table></figure>
<p>职责链中的节点 <code>p1</code> 接收到参数后，无法处理，将请求向后传递，最终由 <code>p3</code> 处理完成后返回了结果 <code>done</code> 。</p>
<p>以上只是抽象的列举了职责链模式的实现方法，实际开发中可以将职责链中的各个节点替换为业务中的方法，如根据不同活动类型、库存等条件计算活动价格等。</p>
<h3 id="用-AOP-实现职责链"><a href="#用-AOP-实现职责链" class="headerlink" title="用 AOP 实现职责链"></a>用 <a href="https://zh.m.wikipedia.org/zh-sg/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">AOP</a> 实现职责链</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'nextSuccessor'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'nextSuccessor'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span> <span class="comment">// 表示处理结束，返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chain = f1.after(f2).after(f3)</span><br><span class="line">chain() <span class="comment">// done</span></span><br></pre></td></tr></table></figure>
<p>用 AOP 来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。</p>
<h3 id="异步的职责链"><a href="#异步的职责链" class="headerlink" title="异步的职责链"></a>异步的职责链</h3><p>我们在上面的代码中实现职责链模式时，让每个节点都返回一个特定的值 <code>nextSuccessor</code> 来表示是否把请求传递给下一个节点。在实际开发中，节点有可能是执行了某些异步操作后才能返回结果，这时就行不通了。所以我们给 <code>Chain</code> 类再增加一个 <code>next</code> 方法，用于手动传递请求给职责链中的下一个节点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'f1'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.next()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'f2'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'f3'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fn = fn</span><br><span class="line">    <span class="keyword">this</span>.successor = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setNextSuccessor(successor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor = successor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply(<span class="keyword">this</span>.successor, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  passRequest() &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply(<span class="keyword">this</span>.successor, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Chain(f1), p2 = <span class="keyword">new</span> Chain(f2), p3 = <span class="keyword">new</span> Chain(f3)</span><br><span class="line"></span><br><span class="line">p1.setNextSuccessor(p2).setNextSuccessor(p3)</span><br><span class="line"></span><br><span class="line">p1.passRequest()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：f1</span></span><br><span class="line"><span class="comment">// 1秒后输出：f2</span></span><br><span class="line"><span class="comment">// 此时执行结束，没有继续向后传递，因为在f2中既没有手动调用next方法，也没有返回'nextSuccessor'</span></span><br></pre></td></tr></table></figure>
<p>现在我们得到了一个节点有权决定什么时候把请求交给下一个节点的特殊链条。</p>
<h3 id="职责链模式的优缺点"><a href="#职责链模式的优缺点" class="headerlink" title="职责链模式的优缺点"></a>职责链模式的优缺点</h3><ul>
<li>优点<ol>
<li>解耦了请求发送者和N个接收者之间的复杂关系（由于不知道链中的哪个节点可以处理你发出的请求，所以你只需要把请求传递给第一个节点即可）。</li>
<li>使用了职责链模式后，链中的节点对象可以灵活地拆分重组。</li>
<li>可以手动指定起始节点，请求不是必须从链中的第一个节点开始传递（在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个 <code>if</code> 判断）。</li>
</ol>
</li>
<li>缺点<ol>
<li>我们无法保证某个请求一定会被链中的节点处理。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。</li>
<li>从性能方面考虑，我们要避免过长的职责链带来的性能损耗。</li>
</ol>
</li>
</ul>
<h2 id="状态（State）模式"><a href="#状态（State）模式" class="headerlink" title="状态（State）模式"></a>状态（State）模式</h2><p>状态模式的定义：<strong>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</strong>。从它的定义中可以看出，状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。</p>
<p>接下来我们看一个示例：</p>
<p>假设我们现在要实现一个灯光程序，灯光有红、绿、黄三种颜色，初始状态为红色，每次点击按钮按照顺序切换一种：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.light = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.light = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="string">'red'</span> <span class="comment">// 设置初始状态</span></span><br><span class="line">    <span class="keyword">const</span> buttonDom = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">    buttonDom.innerHTML = <span class="string">'切换'</span></span><br><span class="line">    buttonDom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.clickButton.call(self)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.lightDom)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(buttonDom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickButton() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.light === <span class="string">'red'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.light = <span class="string">'green'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.light === <span class="string">'green'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.light = <span class="string">'yellow'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.light = <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="keyword">this</span>.light</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light()</span><br><span class="line">light.init()</span><br></pre></td></tr></table></figure>
<p>这样实现非常简单，我们在 <code>Light</code> 类的内部声明了一个 <code>light</code> 属性来保存当前灯的状态（即颜色），再点击按钮时根据这个状态来决定下一步的行为。</p>
<p>但使用这种方式是违反开放-封闭原则的，每次新增或者修改灯光状态时，都要改动 clickButton 方法中的代码，这使得 clickButton 成为了一个非常不稳定的方法，而且随着后期灯光新增的颜色越来越多，这个方法会逐渐膨胀。如果我们想在 red 和 green 中间插入一种新的颜色，那么就需要改动后面的所有 if else 语句，这样会使 clickButton 更加难以阅读和维护。最后如果一个开发者想了解这个灯一共有多少种颜色，需要完整的阅读 clickButton 内的所有代码，不够一目了然。</p>
<h3 id="状态模式的使用"><a href="#状态模式的使用" class="headerlink" title="状态模式的使用"></a>状态模式的使用</h3><p>那么现在我们用状态模式来改进一下上面的代码。通常我们谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以 button 被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。同时我们还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedLight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(light) &#123;</span><br><span class="line">    <span class="keyword">this</span>.light = light</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'red'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.greenLight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenLight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(light) &#123;</span><br><span class="line">    <span class="keyword">this</span>.light = light</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'green'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.yellowLight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowLight</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(light) &#123;</span><br><span class="line">    <span class="keyword">this</span>.light = light</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'yellow'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clickButton() &#123;</span><br><span class="line">    <span class="keyword">this</span>.light.setState(<span class="keyword">this</span>.light.redLight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLight = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.redLight = <span class="keyword">new</span> RedLight(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.greenLight = <span class="keyword">new</span> GreenLight(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.yellowLight = <span class="keyword">new</span> YellowLight(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.currentLight = <span class="keyword">this</span>.redLight <span class="comment">// 设置初始状态</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="keyword">this</span>.currentLight.state</span><br><span class="line">    <span class="keyword">const</span> buttonDom = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">    buttonDom.innerHTML = <span class="string">'切换'</span></span><br><span class="line">    buttonDom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.currentLight.clickButton.call(self.currentLight)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.lightDom)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(buttonDom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setState(newState) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLight = newState</span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="keyword">this</span>.currentLight.state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light()</span><br><span class="line">light.init()</span><br></pre></td></tr></table></figure>
<p>上面的代码我们通过状态模式实现了一样的输出效果。再回顾一下状态模式的定义：</p>
<blockquote>
<p><strong>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</strong></p>
</blockquote>
<p>我们以逗号分割，把这句话分为两部分来看。第一部分的意思是把不同颜色的灯光封装成了独立的类，并将请求委托给当前的状态对象，当对象的内部状态（this.light.currentLight）改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。</p>
<p>使用了状态模式以后，之前提到的问题似乎大部分都被解决了。</p>
<h3 id="状态模式中的性能优化点"><a href="#状态模式中的性能优化点" class="headerlink" title="状态模式中的性能优化点"></a>状态模式中的性能优化点</h3><ul>
<li>有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的 state 对象，并且始终不销毁它们。如果 state 对象比较庞大，可以采用第一种方式来节省内存。但如果 state 对象切换比较频繁，可以一开始就把这些 state 对象都创建出来，也没有必要销毁它们，因为可能很快将再次用到它们。</li>
<li>在上面的例子中，我们为每个 Content 对象都创建了一组 state 对象，实际上各 Content 对象可以共享一个 state 对象，可以搭配享元模式来优化它。</li>
</ul>
<h3 id="状态模式和策略模式的关系"><a href="#状态模式和策略模式的关系" class="headerlink" title="状态模式和策略模式的关系"></a>状态模式和策略模式的关系</h3><p>状态模式和策略模式都封装了一系列的算法或者行为，看起来很像，但在意图上有很大不同。二者相同点是它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。</p>
<h3 id="状态模式的优缺点"><a href="#状态模式的优缺点" class="headerlink" title="状态模式的优缺点"></a>状态模式的优缺点</h3><ul>
<li>优点<ul>
<li>态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。</li>
<li>避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支。</li>
<li>Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。</li>
</ul>
</li>
<li>缺点<ul>
<li>状态模式需要定义多个类，是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。</li>
<li>由于逻辑是分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。</li>
</ul>
</li>
</ul>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>状态模式是状态机的实现之一。有限状态机有如下三个特点：</p>
<ul>
<li>状态总数是有限的。</li>
<li>任意时刻，只会处于某一个状态中。</li>
<li>某种条件下，会从一种状态转换到另一种状态。</li>
</ul>
<p>我们还是来实现一个上面灯光程序的有限状态机。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FSM = &#123;</span><br><span class="line">  redLight: &#123;</span><br><span class="line">    clickButton() &#123;</span><br><span class="line">      <span class="keyword">this</span>.lightDom.innerHTML = <span class="string">'green'</span></span><br><span class="line">      <span class="keyword">this</span>.currentLight = FSM.greenLight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  greenLight: &#123;</span><br><span class="line">    clickButton() &#123;</span><br><span class="line">      <span class="keyword">this</span>.lightDom.innerHTML = <span class="string">'yellow'</span></span><br><span class="line">      <span class="keyword">this</span>.currentLight = FSM.yellowLight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  yellowLight: &#123;</span><br><span class="line">    clickButton() &#123;</span><br><span class="line">      <span class="keyword">this</span>.lightDom.innerHTML = <span class="string">'red'</span></span><br><span class="line">      <span class="keyword">this</span>.currentLight = FSM.redLight</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentLight = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.currentLight = FSM.redLight <span class="comment">// 设置初始状态</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">const</span> buttonDom = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">    buttonDom.innerHTML = <span class="string">'切换'</span></span><br><span class="line">    buttonDom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.currentLight.clickButton.call(self)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.lightDom)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(buttonDom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light()</span><br><span class="line">light.init()</span><br></pre></td></tr></table></figure>
<h3 id="表驱动的有限状态机"><a href="#表驱动的有限状态机" class="headerlink" title="表驱动的有限状态机"></a>表驱动的有限状态机</h3><p>这种有限状态机核心是基于表驱动的。我们可以在表中很清楚地看到下一个状态是由当前状态和行为共同决定的。这样一来，我们就可以在表中查找状态，而不必定义很多条件分支。</p>
<table>
<thead>
<tr>
<th>当前状态→条件↓</th>
<th>状态 A</th>
<th>状态 B</th>
<th>状态 C</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件 X</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>条件 Y</td>
<td>…</td>
<td>状态 C</td>
<td>…</td>
</tr>
<tr>
<td>条件 Z</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>我们可以借助 <a href="https://github.com/jakesgordon/javascript-state-machine" target="_blank" rel="noopener">javascript-state-machine</a> 来轻松的创建一个有限状态机，下面我们用这个库来实现之前的灯光程序。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> StateMachine <span class="keyword">from</span> <span class="string">'javascript-state-machine'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.fsm = <span class="keyword">new</span> StateMachine(&#123;</span><br><span class="line">      init: <span class="string">'red'</span>,</span><br><span class="line">      transitions: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'step'</span>, <span class="attr">from</span>: <span class="string">'red'</span>, <span class="attr">to</span>: <span class="string">'green'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'step'</span>, <span class="attr">from</span>: <span class="string">'green'</span>, <span class="attr">to</span>: <span class="string">'yellow'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'step'</span>, <span class="attr">from</span>: <span class="string">'yellow'</span>, <span class="attr">to</span>: <span class="string">'red'</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="comment">// 观察状态更改生命周期</span></span><br><span class="line">        onStep(lifecycle, instance) &#123;</span><br><span class="line">          <span class="comment">// lifecycle: 一个包含状态更改信息的对象 instance: 执行 step 传进来的参数</span></span><br><span class="line">          instance.lightDom.innerHTML = lifecycle.to</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.lightDom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">this</span>.lightDom.innerHTML = <span class="keyword">this</span>.fsm.state</span><br><span class="line">    <span class="keyword">const</span> buttonDom = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">    buttonDom.innerHTML = <span class="string">'切换'</span></span><br><span class="line">    buttonDom.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      self.fsm.step(self)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.lightDom)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(buttonDom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> Light()</span><br><span class="line">light.init()</span><br></pre></td></tr></table></figure>
<h2 id="观察者（Observer）模式"><a href="#观察者（Observer）模式" class="headerlink" title="观察者（Observer）模式"></a>观察者（Observer）模式</h2><p>观察者模式又叫<strong>发布—订阅模式</strong>，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。</p>
<p>举一个现实世界的例子：小明到4s店去买车，但被销售告知自己看中的型号暂时没货，到货时间不明，于是小明记下了销售的电话，每天都打一个电话去询问车子是否有货。如果有100像小明这样的客户，那么这个销售每天就会接到100个电话来询问车子的到货情况。实际上没有销售会这样做，他只需要记录下等待车子到货的客户名单，车子一到货遍历客户名单发短信通知一遍就可以了。</p>
<p>在刚刚的例子中，销售使用的就是观察者模式。像小明一样的客户是<strong>订阅者</strong>，他们订阅了车子的到货信息。而销售则是<strong>发布者</strong>，车子到货以后会给订阅者们发布到货信息。</p>
<p>观察者模式有两个特点：</p>
<ol>
<li>可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。在异步编程中使用观察者模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</li>
<li>可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。</li>
</ol>
<p>使用 <code>addEventListener</code> 方法在 DOM 上绑定事件函数就是观察者模式的一种应用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.click() <span class="comment">// 模拟用户点击事件</span></span><br></pre></td></tr></table></figure>
<p>我们利用 <code>addEventListener</code> 方法将指定的监听器注册到目标对象上，这里做的就是订阅者的工作，而用户点击该 DOM 元素时充当的就是发布者的角色。</p>
<h3 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h3><p>我们用观察者模式来实现一个上面销售卖车的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seller = &#123;</span><br><span class="line">  clientList: [],</span><br><span class="line">  listen(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.clientList.push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[i++];) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小明订阅车辆到货事件</span></span><br><span class="line">seller.listen(<span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 小红订阅车辆到货事件</span></span><br><span class="line">seller.listen(<span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销售发布车辆到货消息</span></span><br><span class="line">seller.trigger(<span class="string">'10万'</span>)</span><br><span class="line">seller.trigger(<span class="string">'15万'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 车已到货，价格10万元。</span></span><br><span class="line"><span class="comment">// 车已到货，价格10万元。</span></span><br><span class="line"><span class="comment">// 车已到货，价格15万元。</span></span><br><span class="line"><span class="comment">// 车已到货，价格15万元。</span></span><br></pre></td></tr></table></figure>
<p>发布者对象 <code>seller</code> 里有一个 <code>clientList</code> 列表用来保存订阅者事件，订阅者通过调用发布者对象的 <code>listen</code> 方法传入订阅事件来订阅车子的到货情况。车子一旦到货，发布者对象会调用 <code>trigger</code> 方法来按照订阅者事件名单上记录的方法向订阅者发布车子到货事件。这样就实现了一个简单的观察者模式。</p>
<p>但是这里还存在着一个问题，我们看到订阅者收到的是发布者收到的所有消息，那如果小明和小红分别想买不同型号的车，他们也会收到其它型号车辆的订阅消息，这显然是一种浪费。所以我们有必要增加一个用作标识的 <code>key</code> ，来让订阅者只订阅自己感兴趣的内容。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seller = &#123;</span><br><span class="line">  clientList: &#123;&#125;,</span><br><span class="line">  listen(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key])) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger(key, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key]) &amp;&amp; <span class="keyword">this</span>.clientList[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[key][i++];) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小明订阅车型A的到货事件</span></span><br><span class="line">seller.listen(<span class="string">'modelA'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 小红订阅车型B的到货事件</span></span><br><span class="line">seller.listen(<span class="string">'modelB'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销售分别发布两个型号车辆的到货消息</span></span><br><span class="line">seller.trigger(<span class="string">'modelA'</span>, <span class="string">'10万'</span>)</span><br><span class="line">seller.trigger(<span class="string">'modelB'</span>, <span class="string">'15万'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 车已到货，价格10万元。</span></span><br><span class="line"><span class="comment">// 车已到货，价格15万元。</span></span><br></pre></td></tr></table></figure>
<h3 id="观察者模式的通用实现"><a href="#观察者模式的通用实现" class="headerlink" title="观察者模式的通用实现"></a>观察者模式的通用实现</h3><p>我们来实现一个通用型的观察者对象，让任何销售（seller）都可以通过这个对象来给自己添加基本的订阅和发布功能，并且再新增一个取消订阅的功能。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的观察者对象</span></span><br><span class="line"><span class="keyword">const</span> eventObj = &#123;</span><br><span class="line">  clientList: &#123;&#125;,</span><br><span class="line">  listen(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key])) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  trigger(key, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key]) &amp;&amp; <span class="keyword">this</span>.clientList[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[key][i++];) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  remove(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key]) &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key].length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      fn</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = <span class="keyword">this</span>.clientList[key].filter(<span class="function"><span class="params">_fn</span> =&gt;</span> fn !== _fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给传进来的对象装载通用观察者对象的属性及方法</span></span><br><span class="line"><span class="keyword">const</span> installEvent = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> eventObj) &#123;</span><br><span class="line">    obj[key] = eventObj[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seller = &#123;&#125; <span class="comment">// 创建一个发布者对象</span></span><br><span class="line">installEvent(seller)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个订阅事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`f1: 车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`f2: 车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">seller.listen(<span class="string">'modelA'</span>, f1)</span><br><span class="line">seller.listen(<span class="string">'modelA'</span>, f2)</span><br><span class="line">seller.remove(<span class="string">'modelA'</span>, f1) <span class="comment">// 取消订阅</span></span><br><span class="line"></span><br><span class="line">seller.trigger(<span class="string">'modelA'</span>, <span class="string">'10万'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// f1: 车已到货，价格10万元。</span></span><br></pre></td></tr></table></figure>
<h3 id="全局的观察者对象"><a href="#全局的观察者对象" class="headerlink" title="全局的观察者对象"></a>全局的观察者对象</h3><p>再观察一下上面的代码，我们发现还存在着至少两个缺点：</p>
<ol>
<li>我们给每个发布者对象都添加了 <code>clientList</code> 缓存列表， <code>listen</code> 和 <code>trigger</code> 等方法，这其实是一种资源浪费。</li>
<li>小明和销售对象之间还是存在一定耦合性，小明至少要知道销售对象的名字是 <code>seller</code> ，才能顺利的订阅到事件。</li>
</ol>
<p>这里可以创建一个全局的 <code>observer</code> 对象来解决。我们把所有的订阅都交给这个对象，同样发布工作也让这个对象来执行，它充当一个中介者的角色，把订阅者和发布者联系起来。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.clientList = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  on(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key])) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clientList[key].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  emit(key, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key]) &amp;&amp; <span class="keyword">this</span>.clientList[key].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, fn; fn = <span class="keyword">this</span>.clientList[key][i++];) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  off(key, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.clientList[key]) &amp;&amp;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key].length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      fn</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clientList[key] = <span class="keyword">this</span>.clientList[key].filter(<span class="function"><span class="params">_fn</span> =&gt;</span> fn !== _fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个订阅事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`f1: 车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`f2: 车已到货，价格<span class="subst">$&#123;price&#125;</span>元。`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> Observer()</span><br><span class="line">observer.on(<span class="string">'modelA'</span>, f1)</span><br><span class="line">observer.on(<span class="string">'modelA'</span>, f2)</span><br><span class="line">observer.off(<span class="string">'modelA'</span>, f1)</span><br><span class="line">observer.emit(<span class="string">'modelA'</span>, <span class="string">'10万'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// f2: 车已到货，价格10万元。</span></span><br></pre></td></tr></table></figure>
<p>到这里我们已经基本上实现了观察者模式。除了正常的订阅者先订阅事件，发布者再发布的流程之外，也可以先发布再订阅（这通常放生在发布事件的时机比订阅事件早时）。</p>
<p>我们也可以建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 QQ 的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。</p>
<p>还可以增加例如 <code>once</code> 订阅方法让订阅者提供的事件只被发布一次，增加 <code>create</code> 方法创建单独的命名空间 <code>(namespace)</code> 来避免大量订阅事件命名冲突的问题。</p>
<h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><p>观察者模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。</p>
<p>缺点即是创建订阅者本身要消耗一定的时间和内存，如果订阅一个消息后，此消息始终都未发生，这个订阅者会始终存在于内存中。另外，观察者模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。</p>
<h2 id="中介者（Mediator）模式"><a href="#中介者（Mediator）模式" class="headerlink" title="中介者（Mediator）模式"></a>中介者（Mediator）模式</h2><p>面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。</p>
<p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。</p>
<p>假设现在我们要开发一款对战游戏，游戏的首个版本功能比较简单，只支持两个玩家对战，并将对战的结果输出。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.enemy = <span class="literal">null</span> <span class="comment">// 敌人</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> won!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lose() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> lost!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  die() &#123;</span><br><span class="line">    <span class="keyword">this</span>.lose()</span><br><span class="line">    <span class="keyword">this</span>.enemy &amp;&amp; <span class="keyword">this</span>.enemy.win()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建两个玩家</span></span><br><span class="line"><span class="keyword">const</span> player1 = <span class="keyword">new</span> Player(<span class="string">'player1'</span>)</span><br><span class="line"><span class="keyword">const</span> player2 = <span class="keyword">new</span> Player(<span class="string">'player2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为两个玩家相互设置敌人</span></span><br><span class="line">player1.enemy = player2</span><br><span class="line">player2.enemy = player1</span><br><span class="line"></span><br><span class="line">player2.die()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// player2 lost!</span></span><br><span class="line"><span class="comment">// player1 won!</span></span><br></pre></td></tr></table></figure>
<p>我们写一个 <code>Player</code> 类来创建玩家，每个玩家分别有 <code>win</code> 、<code>lose</code> 、<code>die</code> 三个方法来执行对战的过程。</p>
<p>现在我们改进一下游戏，使游戏支持更多的玩家参与，并将多个玩家分成红蓝两队。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> players = [] <span class="comment">// 存放所有玩家的列表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, teamColor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'alive'</span> <span class="comment">// 玩家状态 'alive' | 'dead'</span></span><br><span class="line">    <span class="keyword">this</span>.partners = [] <span class="comment">// 队友列表</span></span><br><span class="line">    <span class="keyword">this</span>.enemies = [] <span class="comment">// 敌人列表</span></span><br><span class="line">    <span class="keyword">this</span>.teamColor = teamColor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`winner: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lose() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`loser: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  die() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'dead'</span></span><br><span class="line">    <span class="comment">// 遍历玩家列表，如果队友都死亡，宣告游戏结束，通知所有玩家结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.partners.every(<span class="function"><span class="params">partner</span> =&gt;</span> partner.state === <span class="string">'dead'</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'游戏结束！'</span>)</span><br><span class="line">      <span class="keyword">this</span>.lose() <span class="comment">// 通知自己游戏失败</span></span><br><span class="line">      <span class="keyword">this</span>.partners.forEach(<span class="function"><span class="params">partner</span> =&gt;</span> &#123;</span><br><span class="line">        partner.lose()</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.enemies.forEach(<span class="function"><span class="params">enemy</span> =&gt;</span> &#123;</span><br><span class="line">        enemy.win()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建玩家的工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerFactory</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor)</span><br><span class="line">  <span class="comment">// 通知所有玩家，有新角色加入</span></span><br><span class="line">  players.forEach(<span class="function"><span class="params">player</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (player.teamColor === newPlayer.teamColor) &#123;</span><br><span class="line">      <span class="comment">// 如果是同一队的玩家，相互添加到队友列表</span></span><br><span class="line">      player.partners.push(newPlayer)</span><br><span class="line">      newPlayer.partners.push(player)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 相互添加到敌人列表</span></span><br><span class="line">      player.enemies.push(newPlayer)</span><br><span class="line">      newPlayer.enemies.push(player)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  players.push(newPlayer)</span><br><span class="line">  <span class="keyword">return</span> newPlayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建红队成员</span></span><br><span class="line"><span class="keyword">const</span> player1 = playerFactory(<span class="string">'player1'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player2 = playerFactory(<span class="string">'player2'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player3 = playerFactory(<span class="string">'player3'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player4 = playerFactory(<span class="string">'player4'</span>, <span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建蓝队成员</span></span><br><span class="line"><span class="keyword">const</span> player5 = playerFactory(<span class="string">'player5'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player6 = playerFactory(<span class="string">'player6'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player7 = playerFactory(<span class="string">'player7'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player8 = playerFactory(<span class="string">'player8'</span>, <span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让红队玩家全部死亡</span></span><br><span class="line">player1.die()</span><br><span class="line">player2.die()</span><br><span class="line">player3.die()</span><br><span class="line">player4.die()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 游戏结束！</span></span><br><span class="line"><span class="comment">// loser: player4</span></span><br><span class="line"><span class="comment">// loser: player1</span></span><br><span class="line"><span class="comment">// loser: player2</span></span><br><span class="line"><span class="comment">// loser: player3</span></span><br><span class="line"><span class="comment">// winner: player5</span></span><br><span class="line"><span class="comment">// winner: player6</span></span><br><span class="line"><span class="comment">// winner: player7</span></span><br><span class="line"><span class="comment">// winner: player8</span></span><br></pre></td></tr></table></figure>
<p>现在我们已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。当每个玩家的状态发生改变时，都要遍历所有玩家来通知到所有对象，一旦玩家数量、游戏队伍或者玩家状态增多时，代码将变得十分复杂，各个玩家队伍的耦合性将十分高，非常不利于维护。</p>
<h3 id="使用中介者模式"><a href="#使用中介者模式" class="headerlink" title="使用中介者模式"></a>使用中介者模式</h3><p>我们用中介者模式来改进一下上面的游戏。新增一个中介者对象 <code>playerDirector</code> ，然后改进 <code>Player</code> 对象，让它不再负责具体的执行逻辑，而是把操作转交给中介者对象。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, teamColor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'alive'</span> <span class="comment">// 玩家状态 'alive' | 'dead'</span></span><br><span class="line">    <span class="keyword">this</span>.teamColor = teamColor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  win() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`winner: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lose() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`loser: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  die() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'dead'</span></span><br><span class="line">    playerDirector.receiveMessage(<span class="string">'playerDead'</span>, <span class="keyword">this</span>) <span class="comment">// 给中介者对象发送消息，玩家死亡</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除玩家</span></span><br><span class="line">  remove() &#123;</span><br><span class="line">    playerDirector.receiveMessage(<span class="string">'removePlayer'</span>, <span class="keyword">this</span>) <span class="comment">// 给中介者对象发送消息，移除一个玩家</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建玩家的工厂方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playerFactory</span>(<span class="params">name, teamColor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newPlayer = <span class="keyword">new</span> Player(name, teamColor)</span><br><span class="line">  playerDirector.receiveMessage(<span class="string">'addPlayer'</span>, newPlayer) <span class="comment">// 给中介者对象发送消息，新增玩家</span></span><br><span class="line">  <span class="keyword">return</span> newPlayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中介者对象</span></span><br><span class="line"><span class="keyword">const</span> playerDirector = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> players = &#123;&#125; <span class="comment">// 分队伍存放所有玩家</span></span><br><span class="line">  <span class="keyword">const</span> operations = &#123;&#125; <span class="comment">// 中介者对象可以执行的所有操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增一个玩家</span></span><br><span class="line">  operations.addPlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> teamColor = player.teamColor</span><br><span class="line">    players[teamColor] = players[teamColor] || [] <span class="comment">// 如果该颜色的队伍还没有成立，则新成立一个队伍</span></span><br><span class="line">    players[teamColor].push(player)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除一个玩家</span></span><br><span class="line">  operations.removePlayer = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> teamPlayers = players[player.teamColor] <span class="comment">// 该队伍的所有队员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历删除</span></span><br><span class="line">    teamPlayers.some(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (teamPlayers[index] === player) &#123;</span><br><span class="line">        teamPlayers.splice(index, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 玩家死亡</span></span><br><span class="line">  operations.playerDead = <span class="function"><span class="keyword">function</span>(<span class="params">player</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> teamPlayers = players[player.teamColor] <span class="comment">// 该队伍的所有队员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历队伍列表，如果队友都死亡，宣告游戏结束，通知所有玩家结果</span></span><br><span class="line">    <span class="keyword">if</span> (teamPlayers.every(<span class="function"><span class="params">partner</span> =&gt;</span> partner.state === <span class="string">'dead'</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'游戏结束！'</span>)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">in</span> players) &#123;</span><br><span class="line">        players[color].forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          color === player.teamColor</span><br><span class="line">            ? item.lose()</span><br><span class="line">            : item.win()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收消息方法</span></span><br><span class="line">  <span class="keyword">const</span> receiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    operations[message].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; receiveMessage &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建红队成员</span></span><br><span class="line"><span class="keyword">const</span> player1 = playerFactory(<span class="string">'player1'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player2 = playerFactory(<span class="string">'player2'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player3 = playerFactory(<span class="string">'player3'</span>, <span class="string">'red'</span>),</span><br><span class="line">      player4 = playerFactory(<span class="string">'player4'</span>, <span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建蓝队成员</span></span><br><span class="line"><span class="keyword">const</span> player5 = playerFactory(<span class="string">'player5'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player6 = playerFactory(<span class="string">'player6'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player7 = playerFactory(<span class="string">'player7'</span>, <span class="string">'blue'</span>),</span><br><span class="line">      player8 = playerFactory(<span class="string">'player8'</span>, <span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除一个玩家</span></span><br><span class="line">player2.remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让红队玩家全部死亡</span></span><br><span class="line">player1.die()</span><br><span class="line">player3.die()</span><br><span class="line">player4.die()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 游戏结束！</span></span><br><span class="line"><span class="comment">// loser: player1</span></span><br><span class="line"><span class="comment">// loser: player3</span></span><br><span class="line"><span class="comment">// loser: player4</span></span><br><span class="line"><span class="comment">// winner: player5</span></span><br><span class="line"><span class="comment">// winner: player6</span></span><br><span class="line"><span class="comment">// winner: player7</span></span><br><span class="line"><span class="comment">// winner: player8</span></span><br></pre></td></tr></table></figure>
<p>可以看到，除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。我们还可以继续给中介者扩展更多功能（例如上面示例中移除玩家的 <code>removePlayer</code> 功能），以适应游戏需求的不断变化。</p>
<h3 id="中介者模式的优缺点"><a href="#中介者模式的优缺点" class="headerlink" title="中介者模式的优缺点"></a>中介者模式的优缺点</h3><ul>
<li><p>优点</p>
<p>  使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。</p>
</li>
<li><p>缺点</p>
<p>  系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p>
</li>
</ul>
<h3 id="中介者模式的总结"><a href="#中介者模式的总结" class="headerlink" title="中介者模式的总结"></a>中介者模式的总结</h3><p>中介者模式是迎合<a href="https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/2107000#:~:text=%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88Law,%E8%8B%B1%E6%96%87%E7%AE%80%E5%86%99%E4%B8%BA%3A%20LOD%E3%80%82" target="_blank" rel="noopener">迪米特法则</a>的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（类似不和陌生人说话）。</p>
<p>中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。</p>
<h2 id="迭代器（Iterator）模式"><a href="#迭代器（Iterator）模式" class="headerlink" title="迭代器（Iterator）模式"></a>迭代器（Iterator）模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p>
<p>现在流行的大部分语言都有了内置的迭代器实现， <code>JavaScript</code> 也提供了 <code>Array.prototype.forEach</code> 方法实现迭代器。</p>
<h3 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function"><span class="keyword">function</span>(<span class="params">arr, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    callback.call(arr[i], arr[i], i, arr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">each([<span class="string">'a'</span>, <span class="string">'b'</span>], (item, i) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, i)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a 0</span></span><br><span class="line"><span class="comment">// b 1</span></span><br></pre></td></tr></table></figure>
<h3 id="内部迭代器和外部迭代器"><a href="#内部迭代器和外部迭代器" class="headerlink" title="内部迭代器和外部迭代器"></a>内部迭代器和外部迭代器</h3><p>先来看一下内部迭代器和外部迭代器的特点：</p>
<ul>
<li>内部迭代器完全接手整个迭代过程，外部只需要一次初始调用。内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。</li>
<li>外部迭代器必须显式地请求迭代下一个元素（<code>next()</code>）。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。</li>
</ul>
<p>我们上面代码实现的代码就是一个内部迭代器，外部只需要调用一次 <code>each</code> 函数即可完成整个迭代。这样虽然很方便，但是如果我们想要在迭代的过程中处理一些事情就很难办到。</p>
<p>下面来看一下外部迭代器的实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OuterIterator = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    current += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current &gt;= obj.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getCurrentItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[current]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next,</span><br><span class="line">    isDone,</span><br><span class="line">    getCurrentItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> outerIterator = OuterIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!outerIterator.isDone()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(outerIterator.getCurrentItem())</span><br><span class="line">    <span class="comment">// do something…</span></span><br><span class="line">    outerIterator.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// done!</span></span><br></pre></td></tr></table></figure>
<p>可以看到，外部迭代器的每一次迭代都是需要我们自己手动调用 <code>next()</code> 方法来实现，就像 <code>Generator</code> 函数，这样就把迭代的控制权交给了我们自己，使迭代器更加灵活。</p>
<p>外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。<strong>内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定</strong>。</p>
<h2 id="访问者（Visitor）模式"><a href="#访问者（Visitor）模式" class="headerlink" title="访问者（Visitor）模式"></a>访问者（Visitor）模式</h2><p>访问者模式是一种将算法与对象结构分离的软件设计模式。</p>
<blockquote>
<p>这个模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象；访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中回调访问者的 visit 方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。《<a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">访问者模式</a>》来自维基百科</p>
</blockquote>
<p>概括来说，就是针对固定的对象结构，给不同的访问者提供不同的操作。</p>
<p>比如我们有一台电脑 <code>Computer</code> ，它是由鼠标 <code>Mouse</code> 、键盘 <code>Keyboard</code> 等不同的硬件组成的，针对不同的硬件我们需要做不同的操作，这里就可以使用访问者对象来处理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> </span>&#123;</span><br><span class="line">  accept(computerVisitor) &#123;</span><br><span class="line">    computerVisitor.visit(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> </span>&#123;</span><br><span class="line">  accept(computerVisitor) &#123;</span><br><span class="line">    computerVisitor.visit(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.parts = [<span class="keyword">new</span> Mouse(), <span class="keyword">new</span> Keyboard()]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accept(computerVisitor) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.parts.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parts[i].accept(computerVisitor) <span class="comment">// 访问电脑的各个设备</span></span><br><span class="line">    &#125;</span><br><span class="line">    computerVisitor.visit(<span class="keyword">this</span>) <span class="comment">// 访问电脑本身</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerVisitor</span> </span>&#123;</span><br><span class="line">  visit(device) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问: '</span>, device.constructor.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> computer = <span class="keyword">new</span> Computer()</span><br><span class="line">computer.accept(<span class="keyword">new</span> ComputerVisitor())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 访问: Mouse</span></span><br><span class="line"><span class="comment">// 访问: Keyboard</span></span><br><span class="line"><span class="comment">// 访问: Computer</span></span><br></pre></td></tr></table></figure>
<p>我们来分析一下上面的代码。这里我们创建了一个 <code>Computer</code> 类，它内部包含 <code>Mouse</code> 、<code>Keyboard</code> 类，它们都提供了一个 <code>accept</code> 方法用来接收访问者对象。后面我们又创建了 <code>ComputerVisitor</code> 类来作为访问者对象，这个对象里面提供了一个 <code>visit</code> 方法，这个方法接收一个元素对象 <code>device</code> ，在这里指代的是电脑的各个部件，我们可以针对不同的元素对象作出不同的处理（上面的代码里我们省略了这部分，只是简单的打印出了各个部件的名字）。</p>
<h2 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h2><p>备忘录模式是一种软件设计模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p>重点在于“不破坏封装性”这几个字上，程序的可维护性永远是设计模式关注的重点，上层框架使用状态时，都不需要知道具体对象状态的细节，而实现这一点的就是 <code>Memento</code> 这个抽象的备忘录类（类似 <code>Redux</code> 的设计原则）。</p>
<p>主要应用就是提供“后悔药”的功能，比如编辑器里的撤销功能，打游戏的存档功能等。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录类（包含了要被恢复的对象的状态）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getContent() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录管理类（负责从 Memento 中恢复对象的状态）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.list = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(memento) &#123;</span><br><span class="line">    <span class="keyword">this</span>.list.push(memento)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.list[index]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并在 Memento 对象中存储状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 这里省略了将 content 设置为“只读”的过程，实际上 content 应该是“只读”的，要修改它只能调用 setContent 方法</span></span><br><span class="line">    <span class="keyword">this</span>.content = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setContent(content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = content</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getContent() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.content</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  saveContentToMemento() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.content)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getContentFromMemento(memento) &#123;</span><br><span class="line">    <span class="keyword">this</span>.content = memento.getContent()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originator = <span class="keyword">new</span> Originator()</span><br><span class="line"><span class="keyword">const</span> caretaker = <span class="keyword">new</span> Caretaker()</span><br><span class="line"></span><br><span class="line">originator.setContent(<span class="string">'#1'</span>)</span><br><span class="line">caretaker.add(originator.saveContentToMemento()) <span class="comment">// 将内容保存至 Caretaker</span></span><br><span class="line">originator.setContent(<span class="string">'#2'</span>)</span><br><span class="line">caretaker.add(originator.saveContentToMemento()) <span class="comment">// 将内容保存至 Caretaker</span></span><br><span class="line">originator.setContent(<span class="string">'#3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(originator.getContent()) <span class="comment">// #3（取到当前内容）</span></span><br><span class="line">originator.getContentFromMemento(caretaker.get(<span class="number">0</span>)) <span class="comment">// 恢复到首次保存的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(originator.getContent()) <span class="comment">// #1（取到当前内容为首次保存的内容）</span></span><br></pre></td></tr></table></figure>
<p>备忘录模式的缺点就是消耗资源。因为存储的是完整状态而非 <code>Diff</code> ，所以如果类的成员过多，会占用大量的内存。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/js-package.html" rel="next" title="前端包管理工具">
                <i class="fa fa-chevron-left"></i> 前端包管理工具
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/js-file-type.html" rel="prev" title="JavaScript验证文件格式">
                JavaScript验证文件格式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://cdn.xiekaifei.com/image/avatar.jpg" alt="Kaifei Xie">
            
              <p class="site-author-name" itemprop="name">Kaifei Xie</p>
              <p class="site-description motion-element" itemprop="description">谢凯飞的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:xkf@xiekaifei.com" target="_blank" title="E-mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript的23种设计模式"><span class="nav-number">1.</span> <span class="nav-text">JavaScript的23种设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是设计模式"><span class="nav-number">2.</span> <span class="nav-text">什么是设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">3.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单例（Singleton）模式"><span class="nav-number">3.1.</span> <span class="nav-text">单例（Singleton）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态属性实现单例模式"><span class="nav-number">3.1.1.</span> <span class="nav-text">静态属性实现单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包实现单例模式"><span class="nav-number">3.1.2.</span> <span class="nav-text">闭包实现单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写构造函数实现单例模式"><span class="nav-number">3.1.3.</span> <span class="nav-text">重写构造函数实现单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用（惰性）单例模式"><span class="nav-number">3.1.4.</span> <span class="nav-text">通用（惰性）单例模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型（Prototype）模式"><span class="nav-number">3.2.</span> <span class="nav-text">原型（Prototype）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂方法（Factory-Method）模式"><span class="nav-number">3.3.</span> <span class="nav-text">工厂方法（Factory Method）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">3.3.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式"><span class="nav-number">3.3.2.</span> <span class="nav-text">工厂方法模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象工厂（Abstract-Factory）模式"><span class="nav-number">3.4.</span> <span class="nav-text">抽象工厂（Abstract Factory）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建造者（Builder）模式"><span class="nav-number">3.5.</span> <span class="nav-text">建造者（Builder）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理（Proxy）模式"><span class="nav-number">3.6.</span> <span class="nav-text">代理（Proxy）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式实现"><span class="nav-number">3.6.1.</span> <span class="nav-text">模式实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保护代理"><span class="nav-number">3.6.2.</span> <span class="nav-text">保护代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟代理"><span class="nav-number">3.6.3.</span> <span class="nav-text">虚拟代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存代理"><span class="nav-number">3.6.4.</span> <span class="nav-text">缓存代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6中的Proxy"><span class="nav-number">3.6.5.</span> <span class="nav-text">ES6中的Proxy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#适配器（Adapter）模式"><span class="nav-number">3.7.</span> <span class="nav-text">适配器（Adapter）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桥接（Bridge）模式"><span class="nav-number">3.8.</span> <span class="nav-text">桥接（Bridge）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰者（Decorator）模式"><span class="nav-number">3.9.</span> <span class="nav-text">装饰者（Decorator）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰者模式的简单实现"><span class="nav-number">3.9.1.</span> <span class="nav-text">装饰者模式的简单实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-AOP-装饰函数"><span class="nav-number">3.9.2.</span> <span class="nav-text">用 AOP 装饰函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰模式与代理模式的区别"><span class="nav-number">3.9.3.</span> <span class="nav-text">装饰模式与代理模式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外观（Facade）模式"><span class="nav-number">3.10.</span> <span class="nav-text">外观（Facade）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#享元（Flyweight）模式"><span class="nav-number">3.11.</span> <span class="nav-text">享元（Flyweight）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合（Composite）模式"><span class="nav-number">3.12.</span> <span class="nav-text">组合（Composite）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组合模式示例"><span class="nav-number">3.12.1.</span> <span class="nav-text">组合模式示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要注意的点"><span class="nav-number">3.12.2.</span> <span class="nav-text">需要注意的点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立双向映射关系"><span class="nav-number">3.12.3.</span> <span class="nav-text">建立双向映射关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用组合模式"><span class="nav-number">3.12.4.</span> <span class="nav-text">何时使用组合模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板方法（Template-Method）模式"><span class="nav-number">3.13.</span> <span class="nav-text">模板方法（Template Method）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模板方法示例"><span class="nav-number">3.13.1.</span> <span class="nav-text">模板方法示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#好莱坞原则"><span class="nav-number">3.13.2.</span> <span class="nav-text">好莱坞原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解释器（Interpreter）模式"><span class="nav-number">3.14.</span> <span class="nav-text">解释器（Interpreter）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略（Strategy）模式"><span class="nav-number">3.15.</span> <span class="nav-text">策略（Strategy）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用策略模式重构方法"><span class="nav-number">3.15.1.</span> <span class="nav-text">使用策略模式重构方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript版本的策略模式"><span class="nav-number">3.15.2.</span> <span class="nav-text">JavaScript版本的策略模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#策略模式的优缺点"><span class="nav-number">3.15.3.</span> <span class="nav-text">策略模式的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令（Command）模式"><span class="nav-number">3.16.</span> <span class="nav-text">命令（Command）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript中的命令模式"><span class="nav-number">3.16.1.</span> <span class="nav-text">JavaScript中的命令模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令模式实现撤销和重做"><span class="nav-number">3.16.2.</span> <span class="nav-text">命令模式实现撤销和重做</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#职责链（Chain-of-Responsibility）模式"><span class="nav-number">3.17.</span> <span class="nav-text">职责链（Chain of Responsibility）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用-AOP-实现职责链"><span class="nav-number">3.17.1.</span> <span class="nav-text">用 AOP 实现职责链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步的职责链"><span class="nav-number">3.17.2.</span> <span class="nav-text">异步的职责链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#职责链模式的优缺点"><span class="nav-number">3.17.3.</span> <span class="nav-text">职责链模式的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态（State）模式"><span class="nav-number">3.18.</span> <span class="nav-text">状态（State）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#状态模式的使用"><span class="nav-number">3.18.1.</span> <span class="nav-text">状态模式的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态模式中的性能优化点"><span class="nav-number">3.18.2.</span> <span class="nav-text">状态模式中的性能优化点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态模式和策略模式的关系"><span class="nav-number">3.18.3.</span> <span class="nav-text">状态模式和策略模式的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态模式的优缺点"><span class="nav-number">3.18.4.</span> <span class="nav-text">状态模式的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有限状态机"><span class="nav-number">3.18.5.</span> <span class="nav-text">有限状态机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表驱动的有限状态机"><span class="nav-number">3.18.6.</span> <span class="nav-text">表驱动的有限状态机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者（Observer）模式"><span class="nav-number">3.19.</span> <span class="nav-text">观察者（Observer）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式的实现"><span class="nav-number">3.19.1.</span> <span class="nav-text">观察者模式的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式的通用实现"><span class="nav-number">3.19.2.</span> <span class="nav-text">观察者模式的通用实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局的观察者对象"><span class="nav-number">3.19.3.</span> <span class="nav-text">全局的观察者对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式的优缺点"><span class="nav-number">3.19.4.</span> <span class="nav-text">观察者模式的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中介者（Mediator）模式"><span class="nav-number">3.20.</span> <span class="nav-text">中介者（Mediator）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用中介者模式"><span class="nav-number">3.20.1.</span> <span class="nav-text">使用中介者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中介者模式的优缺点"><span class="nav-number">3.20.2.</span> <span class="nav-text">中介者模式的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中介者模式的总结"><span class="nav-number">3.20.3.</span> <span class="nav-text">中介者模式的总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器（Iterator）模式"><span class="nav-number">3.21.</span> <span class="nav-text">迭代器（Iterator）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现自己的迭代器"><span class="nav-number">3.21.1.</span> <span class="nav-text">实现自己的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部迭代器和外部迭代器"><span class="nav-number">3.21.2.</span> <span class="nav-text">内部迭代器和外部迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问者（Visitor）模式"><span class="nav-number">3.22.</span> <span class="nav-text">访问者（Visitor）模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备忘录（Memento）模式"><span class="nav-number">3.23.</span> <span class="nav-text">备忘录（Memento）模式</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaifei Xie</span>

  
</div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
