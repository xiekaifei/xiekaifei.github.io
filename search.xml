<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript验证文件格式]]></title>
    <url>%2F2023%2Fjs-file-type.html</url>
    <content type="text"><![CDATA[一、利用唯一文件类型说明符限制上传文件类型唯一文件类型说明符，表示在 file 类型的 input 元素中用户可以选择的文件类型。每个唯一文件类型说明符可以采用下列形式之一： 一个以英文句号（“.”）开头的合法的不区分大小写的文件名扩展名。例如：.jpg、.pdf 或 .doc 。 一个不带扩展名的 MIME 类型字符串。 字符串 audio/*，表示“任何音频文件”。 字符串 video/*，表示“任何视频文件”。 字符串 image/*，表示“任何图片文件”。 accept 属性的值是包含一个或多个（用逗号分隔）唯一文件类型说明符的字符串。例如，一个文件选择器需要能被表示成一张图片的内容，包括标准的图片格式和 PDF 文件，大概是这样的： 1&lt;input type="file" accept="image/*,.pdf" /&gt; 这种方式，在 Mac OS 系统中表现为：不被允许的文件类型在上传文件框中呈现为灰色不可选状态，无法选中上传。在 Windows 系统中表现为：上传文件框中只展示可被上传的文件类型。而这个限制在 Windows 系统中可以被轻松绕过（选择上传文件框右下角的 All Files 选项）。 二、利用 MIME 类型验证文件类型媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。 通用结构（语法）： 1type/subtype 常见 MIME 类型列表 我们可以在用户上传文件后，从 File 对象的 type 字段拿到文件的 MIME 类型，来验证文件类型是否合法，这种方式可以规避掉唯一文件类型说明符限制上传文件类型被 Windows 系统绕过的缺点。 例如，我们来验证用户上传 .png 类型的图片： 12345678const input = document.querySelector('input')input.addEventListener('change', function() &#123; const [file] = input.files if (file.type !== 'image/jpeg') &#123; alert('请上传 .png 文件') input.value = '' &#125;&#125;) 这种方式同样也有缺点。用户可以修改文件的后缀名来实现修改文件 MIME 类型的方法，绕开检查，这种方式相对来说安全性也不是很高。 三、利用文件 Magic number 验证文件类型Magic number ，又称之为 魔术数字 。在文件中，魔术数字指： 在特定文件格式中加入固定数值和固定字符串，然后便可以通过检查文件是否包含这些数据来快速地识别文件格式。 例如：GIF文件开头会包含GIF89a（47 49 46 38 39 61）或GIF87a（47 49 46 38 37 61）这两种字符串。 我们可以利用这个特性，通过读取并比对文件头部的 Macic number 来验证文件的格式，大多数文件类型都能做到在同一种文件类型下的不同文件，它的 Magic number 一致，但是也有例外如：.csv 、.json 格式的文件。 并非所有类型的文件都有 Magic number ，所以这也不是 100％可靠的方式。 还是上传文件的场景，我们在拿到用户上传的文件后，可以利用 FileReader 接口提供的 readAsArrayBuffer 方法来读取文件的内容，这会返回一个 ArrayBuffer 对象以表示所读取文件的数据，我们将这个 ArrayBuffer 对象转换成16进制的字符串，去和对应类型的 Magic number 做比对，即可分辨出用户上传的文件是否为目标类型。 各文件类型的 Magic number 示例可以在这里查看到。 下面我们拆解流程来一步步看。首先定义一个 ArrayBuffer 对象转16进制的方法： 12345678910111213/** * ArrayBuffer对象转16进制字符串 * @param &#123;ArrayBuffer&#125; arrayBuffer * @return &#123;String&#125; 转换后的16进制字符串 */function arrayBufferToHex(arrayBuffer) &#123; return Array.prototype.map.call( new Uint8Array(arrayBuffer), function (bit) &#123; return ('00' + bit.toString(16)).slice(-2) &#125; ).join('')&#125; 然后，我们模拟一个 &lt;input type=&quot;file&quot; /&gt; 上传标签拿到用户上传文件后并获取文件类型 Magic number 的过程： 1234567891011const input = document.querySelector('input')input.addEventListener('change', function() &#123; const [file] = input.files const reader = new FileReader() reader.onloadend = function() &#123; const result = arrayBufferToHex(reader.result) console.log(result) // 最终拿到的文件 Magic number: 89504e470d0a1a0a &#125; // 这里我们假设用户上传的是 .png 格式的文件，只取文件前8字节的数据 reader.readAsArrayBuffer(file.slice(0, 8))&#125;) 这里需要注意，通常文件类型 Magic number 会标识在文件的最前面（具体类型查看维基百科示例），例如 .png 格式的文件，示例里描述说该类型的文件以8字节的签名文件开始（89 50 4E 47 0D 0A 1A 0A），以此标识为 .png 格式。所以，如果要验证这种类型的文件，我们只需要利用 File 接口的 slice 方法提取文件前8字节的数据做转换判断即可，而无需将整个文件都参与到验证中来，这样在处理较大文件时会节省很多性能消耗。 最后，我们只需要将最后转换好的16进制 Magic number 与 .png 格式文件对应的 Magic number 比对即可。 在实际使用中，我们可以把验证具体类型文件的需求封装成具体的方法，应用在项目中即可。我们来封装一个 isPdf 方法，来验证用户上传的文件是否为 pdf 格式。 1234567891011121314151617181920212223242526272829303132333435/** * ArrayBuffer对象转16进制字符串 * @param &#123;ArrayBuffer&#125; arrayBuffer * @return &#123;String&#125; 转换后的16进制字符串 */function arrayBufferToHex(arrayBuffer) &#123; return Array.prototype.map.call( new Uint8Array(arrayBuffer), function (bit) &#123; return ('00' + bit.toString(16)).slice(-2) &#125; ).join('')&#125;async function isPdf(file) &#123; return new Promise((resolve, reject) =&gt; &#123; const reader = new FileReader() reader.onloadend = function() &#123; const fileMagicNumber = arrayBufferToHex(reader.result) resolve(fileMagicNumber === '25504446') &#125; reader.onerror = reject reader.readAsArrayBuffer(file.slice(0, 4)) // pdf类型的文件只需要4个字节内容即可判断 &#125;) &#125;const input = document.querySelector('input')input.addEventListener('change', async function() &#123; const [file] = input.files const result = await isPdf(file) if (!result) &#123; alert('请上传 pdf 文件') input.value = '' &#125;&#125;)]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式]]></title>
    <url>%2F2023%2Fjs-design-patterns.html</url>
    <content type="text"><![CDATA[JavaScript的23种设计模式 范围/目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法 （类）适配器 模板方法 解释器 对象模式 单例 原型 抽象工厂 建造者 代理 （对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 本篇博客介绍了 JavaScript 的23种设计模式，其中大部分思想与示例来自于《JavaScript设计模式与开发实践》一书，所以本文更像是我对该书的学习笔记，书中没有讲到的设计模式经过其他途径学习总结后均有提到。传统的面向对象程序设计语言有23种设计模式，本文中的部分设计模式可能仅仅是为了让未来的自己和读者了解其设计思想（如解释器模式），在实际开发中很少用到。 什么是设计模式 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其他非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。 设计模式单例（Singleton）模式单例模式即保证一个类仅能有一个实例，且全局可以访问该实例。 其实现原理是：创建实例时，缓存实例，后面创建时先判断有没有创建过，有的话直接返回。也就是说主要实现逻辑在缓存实例这里，我们可以用静态属性、闭包、重写构造函数等几种不同的方式来实现单例模式。 单例模式实际大多应用在只存在唯一一个实例的场景，如登录框、统一页面浮窗等。 静态属性实现单例模式1234567891011121314151617// ES5版本function Singleton(name) &#123; if (Singleton.instance) &#123; return Singleton.instance // 如果有缓存直接返回 &#125; this.name = name return Singleton.instance = this // 将静态属性instance设置为首个实例（缓存）&#125;Singleton.prototype.sayName = function() &#123; console.log(this.name)&#125;const s1 = new Singleton('s1')const s2 = new Singleton('s2')console.log(s1 === s2) // true，说明两个实例是同一个s2.sayName() // 's1' 123456789101112131415161718192021// ES6版本class Singleton &#123; static instance // 定义一个静态属性 constructor(name) &#123; if (Singleton.instance) &#123; return Singleton.instance // 如果有缓存直接返回 &#125; this.name = name return Singleton.instance = this // 将静态属性instance设置为首个实例（缓存） &#125; sayName() &#123; console.log(this.name) &#125;&#125;const s1 = new Singleton('s1')const s2 = new Singleton('s2')console.log(s1 === s2) // true，说明两个实例是同一个s2.sayName() // 's1' 闭包实现单例模式12345678910111213141516171819const Singleton = (function() &#123; let instance = null // 设置私有变量instance const CreateSingleton = function(name) &#123; if (instance) &#123; return instance &#125; this.name = name return instance = this &#125; CreateSingleton.prototype.sayName = function() &#123; console.log(this.name) &#125; return CreateSingleton&#125;())const s1 = new Singleton('s1')const s2 = new Singleton('s2')console.log(s1 === s2) // trues2.sayName() // 's1' 重写构造函数实现单例模式12345678910111213141516171819202122232425262728293031323334function Singleton(name) &#123; // 缓存实例 let instance // 重写构造函数 Singleton = function() &#123; this.name = name return instance &#125; // 保留原型 Singleton.prototype = this.constructor.prototype // 将重写后的构造函数的原型指回原构造函数的原型，使首次声明的实例可以正确访问到原型链上的属性与方法（Singleton.prototype.a = 1，使其生效） // 定义原型方法 Singleton.prototype.sayName = function() &#123; console.log(this.name) &#125; // 创建实例 instance = new Singleton() // 设置构造函数 instance.constructor = Singleton // 将实例的构造函数指向被重写后的Singleton return instance // 首次使用该构造函数时，直接返回instance实例。再次使用时因为构造函数已被重写，一样返回instance实例。&#125;Singleton.prototype.a = 1 // 此时的代码是给重写前的构造函数的原型上添加了属性aconst s1 = new Singleton('s1')const s2 = new Singleton('s2')console.log(s1.constructor) // 此时s1.constructor指向重写后的构造函数console.log(s1 === s2) // trues2.sayName() // 's1'console.log(s1.a) // 1 通用（惰性）单例模式123456const createSingleton = function(fn) &#123; let result = null return function() &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125; 以上方法用于创建通用（惰性）单例模式。该方法创建出来的单例模式还具有惰性的特点，真正调用的时候单例才会被创建，而不是页面加载后立即被创建。 用法： 123456789function test() &#123; return &#123; a: 1 &#125;&#125;const s = createSingleton(test) // 使用通用单例模式封装const t1 = s()const t2 = s()console.log(t1 === t2) // true，此时生成的两个对象全等，其实返回的始终是一个对象 原型（Prototype）模式原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式不单是一种设计模式，也被称为一种编程泛型。 从设计模式的角度讲，原型模式是用于创建对象的一种模式。我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象（使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享）。在其他语言很少使用原型模式，但是JavaScript作为原型语言，在构造新对象及其原型时会使用该模式。 原型上的属性与方法是被实例共享的： 1234567891011121314151617function Person(name) &#123; this.name = name this.sayHi = function() &#123; // 实例方法 console.log('Hi') &#125;&#125;// 在原型上添加方法Person.prototype.sayName = function() &#123; console.log(this.name)&#125;const p1 = new Person('张三')const p2 = new Person('李四')console.log(p1.sayHi === p2.sayHi) // falseconsole.log(p1.sayName === p2.sayName) // true// 因为使用原型模式可以使示例共享属性和方法，避免重复创建，可以带来性能上的提升 利用以上特性，我们可以实现使用原型模式创建新对象。 ECMAScript 5新增了 Object.create() 方法可以直接使用原型模式创建新对象。 Object.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 12345678// 以下示例仅展示Object.create()方法第一个参数的用法const obj = &#123; a: 1&#125;const obj2 = Object.create(obj)console.log(obj2.a) // 1console.log(obj2.__proto__ === obj) // true 但是需要注意从原型上继承来的属性和方法具有动态性： 12obj.a = 2console.log(obj2.a) // 2 Object.create()方法的实现过程（第一个参数）: 1234567// 核心思想是创建一个新的函数，将新函数的prototype属性指向原函数，再返回这个新创建的函数function object(o) &#123; function F() &#123;&#125; F.prototype = o return new F()&#125; 工厂方法（Factory Method）模式工厂方法模式是一个用于创建对象的接口，它提供了一种将实例化逻辑委托给子类的方法。工厂方法允许一个类延迟实例化它使用的子类。 先来看一下工厂模式。 工厂模式工厂模式即抽象了创建 具体对象的过程，将创建对象的过程进行了单独的封装。 1234567891011121314// 一个简单的工厂模式的示例function createPerson(name, age) &#123; const o = new Object() o.name = name o.age = age o.sayName = function() &#123; console.log(this.name) &#125; return o&#125;const p1 = createPerson('张三', 18)const p2 = createPerson('李四', 20)p1.sayName() // '张三' 工厂方法模式正如工厂方法模式的定义所说： 一个用于创建对象的接口，它提供了一种将实例化逻辑委托给子类的方法。工厂方法允许一个类延迟实例化它使用的子类。 1234567891011121314151617181920212223242526272829// 一个使用工厂方法模式创建员工的示例function Person(name, age) &#123; this.name = name this.age = age&#125;function CreateProgrammer(name, age) &#123; Person.apply(this, arguments) // 继承基类 this.work = 'write the code' this.tools = ['computer', 'keyboard']&#125;function CreateDriver(name, age) &#123; Person.apply(this, arguments) // 继承基类 this.work = 'drive' this.tools = ['car']&#125;function createStaff(name, age, job) &#123; switch(job) &#123; // 根据参数实例化相应的类 case 'Programmer': return new CreateProgrammer(name, age) case 'Driver': return new CreateDriver(name, age) default: throw new Error('参数错误，可选参数: [Programmer, Driver]') &#125;&#125;const p1 = createStaff('张三', 18, 'Programmer')const p2 = createStaff('李四', 19, 'Driver') 上面的示例可以让我们通过传入员工的基本信息来创建出任意多个员工，不过员工的类型无法扩展，下面来看一个优化后的示例。 123456789101112131415161718192021222324252627282930313233function Person(name, age) &#123; this.name = name this.age = age&#125;function createStaff(name, age, job) &#123; if (typeof createStaff.prototype[job] !== 'function') &#123; throw new Error('员工类型错误！') &#125; // createStaff是一个普通函数，而非构造函数，首次不加new运算符使用时，会跑入else代码块 if (this instanceof createStaff) &#123; return new this[job](name, age) &#125; else &#123; return new createStaff(...arguments) &#125;&#125;createStaff.prototype = &#123; 'Programmer': function(name, age) &#123; Person.call(this, name, age) // 继承基类 this.work = 'write the code' this.tools = ['computer', 'keyboard'] &#125;&#125;// 添加一个员工类型createStaff.prototype.Driver = function(name, age) &#123; Person.call(this, name, age) // 继承基类 this.work = 'drive' this.tools = ['car']&#125;const p1 = createStaff('张三', 18, 'Programmer')const p2 = createStaff('李四', 19, 'Driver') 抽象工厂（Abstract Factory）模式抽象工厂模式(Abstract Factory)就是通过类的抽象使得业务适用于一个产品类簇的创建，而不负责某一类产品的实例。 抽象工厂模式需要有抽象类来为子类指明必须实现哪些方法，而目前JavaScript没有抽象类的概念，abstract 曾在JavaScript中是保留字（ECMAScript1-3）。我们可以用 throw 语句抛出异常的方式来模拟抽象类和抽象方法。抽象类无法直接被实例化，必须被子类继承使用。而继承了抽象类的子类也必须自行覆盖抽象类中的抽象方法，否则当子类直接调用从抽象类中继承过来的抽象方法时会报错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 首先声明四个实体类function Programmer() &#123; this.title = '开发者'&#125;function Driver() &#123; this.title = '司机'&#125;function Monitor() &#123; this.title = '班长'&#125;function GroupLeader() &#123; this.title = '组长'&#125;// 接着定义抽象工厂方法AbstractFactoryfunction AbstractFactory() &#123; throw new Error('抽象工厂类无法直接调用')&#125;AbstractFactory.prototype.createStaff = function() &#123; throw new Error('无法直接调用抽象方法，子类请实现接口')&#125;AbstractFactory.prototype.createStudent= function() &#123; throw new Error('无法直接调用抽象方法，子类请实现接口')&#125;// 定义创建员工工厂方法function StaffFactory() &#123;&#125;StaffFactory.prototype = Object.create(AbstractFactory.prototype) // 继承抽象工厂方法StaffFactory.prototype.constructor = StaffFactory // 保持构造函数具有正确的指向StaffFactory.prototype.createStaff = function(job) &#123; switch(job) &#123; case 'programmer': return new Programmer() case 'driver': return new Driver() default: throw new Error('参数错误，可选参数: [programmer, driver]') &#125;&#125;// 定义创建学生工厂方法function StudentFactory() &#123;&#125;StudentFactory.prototype = Object.create(AbstractFactory.prototype)StudentFactory.prototype.constructor = StudentFactoryStudentFactory.prototype.createStudent = function(job) &#123; switch(job) &#123; case 'monitor': return new Monitor() case 'group-leader': return new GroupLeader() default: throw new Error('参数错误，可选参数: [monitor, group-leader]') &#125;&#125;function Factory(type) &#123; switch(type) &#123; case 'staff': return new StaffFactory() case 'student': return new StudentFactory() default: throw new Error('工厂方法不存在') &#125;&#125;// 用法const staff = new Factory('staff') // 创建员工工厂方法const staffItem = staff.createStaff('programmer') // 根据员工实体类创建的员工console.log(staffItem.title) // '开发者'const student = new Factory('student')const studentItem = student.createStudent('monitor')console.log(studentItem.title) // '班长' 建造者（Builder）模式建造者模式将一个复杂的对象分解成多个简单的对象来进行构建，分步构建一个复杂对象，并允许按步骤构造。同样的构建过程可以采用不同的表示，将一个复杂对象的 构建层与其表示层分离。 建造者模式包含建造者类、指挥者类和最终生成的产品。用户无需知道用怎样的方式来装配对象，只需要给指挥者类传入类型，由指挥者类决定以怎样的方式装配对象，以得到最终的产品。 123456789101112131415161718192021222324252627282930313233343536// 定义一个用户类（建造者类）function UserBuilder() &#123;&#125;// 在用户类上添加方法UserBuilder.prototype.setName = function(name) &#123; this.name = name&#125;UserBuilder.prototype.setGender = function (gender) &#123; switch(parseInt(gender)) &#123; case 1: this.gender = '男' break case 2: this.gender = '女' break default: this.gender = '未知' &#125;&#125;UserBuilder.prototype.setAge = function(age) &#123; this.age = age&#125;// 定义一个指挥者类function UserDirector(name, gender, age) &#123; const user = new UserBuilder() user.setName(name) user.setGender(gender) user.setAge(age) return user&#125;// 使用（生成一个产品）const user1 = UserDirector('小明', 1, 18)console.log(user1) // &#123;name: "小明", gender: "男", age: 18&#125; 使用结合链式调用的创建者模式： 1234567891011121314151617181920212223242526272829303132// 定义一个用户类（建造者类）function UserBuilder() &#123;&#125;// 在用户类上添加方法UserBuilder.prototype.setName = function(name) &#123; this.name = name return this&#125;UserBuilder.prototype.setGender = function (gender) &#123; switch(parseInt(gender)) &#123; case 1: this.gender = '男' break case 2: this.gender = '女' break default: this.gender = '未知' &#125; return this&#125;UserBuilder.prototype.setAge = function(age) &#123; this.age = age return this&#125;// 使用（在这里产品也充当了指挥者的角色，自行选配需要的对象）const user1 = new UserBuilder() .setName('小明') .setAge(20);console.log(user1) // &#123;name: "小明", age: 20&#125; 代理（Proxy）模式代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。 在设计代理对象时，需要考虑代理接口和本体接口的一致性。 模式实现1234567891011121314// 小明有一个接电话的方法const xiaoming = &#123; acceptCall: function(phoneNumber) &#123; console.log(`成功接听电话"$&#123;phoneNumber&#125;"`) &#125;&#125;// 代理人代理了小明的电话const proxy = &#123; acceptCall: function(phoneNumber) &#123; xiaoming.acceptCall(phoneNumber) &#125;&#125;proxy.acceptCall('10010') // 成功接听电话"10010" 保护代理保护代理即代理对象会帮目标对象过滤掉一部分请求的代理模式。 1234567891011121314151617181920// 小明有一个接电话的方法const xiaoming = &#123; acceptCall: function(phoneNumber) &#123; console.log(`成功接听电话"$&#123;phoneNumber&#125;"`) &#125;&#125;// 代理人代理了小明的电话，判断来电如果不在黑名单内就把来电转接给小明const proxy = &#123; acceptCall: function(phoneNumber) &#123; const blacklist = ['10086'] if (blacklist.includes(phoneNumber)) &#123; console.log(`电话"$&#123;phoneNumber&#125;"在黑名单中，拒绝接听!`) &#125; else &#123; xiaoming.acceptCall(phoneNumber) &#125; &#125;&#125;proxy.acceptCall('10086') // 电话"10086"在黑名单中，拒绝接听!proxy.acceptCall('10010') // 成功接听电话"10010" 虚拟代理虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。 下面的示例在DOM树中创建了一个图片节点，通过代理对象在图片节点引用的图片资源没有加载完成时展示一张loading图片。 12345678910111213141516171819202122232425var myImage = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();var proxyImage = (function() &#123; var img = new Image; img.onload = function() &#123; myImage.setSrc(this.src); &#125; return &#123; setSrc: function(src) &#123; myImage.setSrc('file:///C:/Users/svenzeng/Desktop/loading.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('&lt;http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&gt;');// 《JavaScript设计模式与开发实践》 如果不使用虚拟代理来实现以上方法： 123456789101112131415161718var MyImage = (function() &#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image; img.onload = function() &#123; imgNode.src = img.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = 'file:///C:/Users/svenzeng/Desktop/loading.gif'; img.src = src; &#125; &#125;&#125;)();MyImage.setSrc('&lt;http://imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&gt;');// 《JavaScript设计模式与开发实践》 这样虽然可以实现功能，但是违反了面向对象设计的原则：单一职责原则。 单一职责原则指的是，就一个类(通常也包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。 上段代码中的 MyImage 对象除了负责给 img 节点设置 src 外，还要负责预加载图片。如果我们只是从网络上获取一些体积很小的图片，或者 5 年后的网速快到根本不再需要预加载，我们可能希望把预加载图片的这段代码从 MyImage 对象里删掉。这时候就不得不改动 MyImage 对象了。 上述虚拟代理示例中实现的代理对象 proxyImage 与本体对象 myImage 都接收 src 属性且都对外提供了 setSrc 方法，在客户看来，代理对象和本体是一致的，保证了代理接口和本体接口的一致性。 缓存代理缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参 数跟之前一致，则可以直接返回前面存储的运算结果。 1234567891011121314151617181920212223242526// 首先定义一个计算乘积的函数function mult() &#123; console.log('开始计算乘积') let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a *= arguments[i] &#125; return a&#125;mult(1, 2, 3) // 输出：开始计算乘积// 现在加入缓存代理函数const proxyMult = (function() &#123; const cache = &#123;&#125; return function() &#123; const args = Array.prototype.join.call(arguments, ',') if (args in cache) &#123; return cache[args] &#125; return cache[args] = mult.apply(this, arguments) &#125;&#125;())proxyMult(1, 2, 3) // 输出：开始计算乘积proxyMult(1, 2, 3) 缓存代理可以用于缓存ajax异步请求的数据，如分页数据等。 ES6中的ProxyProxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。 使用 new 运算符创建一个 Proxy 对象，接收一个要包装的目标对象 target 参数，一个定义执行各种操作时代理行为的对象 handler 参数，handler 对象是一个容纳一批特定属性的占位符对象，包含所有捕捉器方法，如果没有定义某个捕捉器，那么就会保留源对象的默认行为。 handler 对象包含如 get 、set 、apply …… 等多个捕捉器，分别对应不同的代理行为。 123456789101112131415161718192021222324const target = &#123; a: 1&#125;const handler = &#123; get(target, propkey, receiver) &#123; console.log('getting: ', propkey) console.log(proxy === receiver) // receiver 代表 Proxy 或者继承Proxy的对象，通常是 proxy 本身 return 123 // 访问 target 下面的所有属性均返回 123 &#125;, set(target, propkey, value, receiver) &#123; console.log('setting: ', propkey) target[propkey] = value // 将 target 下面的所有属性均设置为传入的 value 值 return true // set() 方法应当返回一个布尔值，返回 true 表示属性设置成功 &#125;&#125;const proxy = new Proxy(target, handler)proxy.b = 2// setting: bconsole.log(proxy.b)// getting: b// true// 123 利用 Proxy 的特性实现一个简易的数据视图双向绑定。 12345678910111213141516171819202122232425262728const proxy = new Proxy(&#123;&#125;, &#123; set(target, propKey, value) &#123; let dom = document.getElementById(propKey) if (dom) &#123; dom.innerHTML = value &#125; else &#123; dom = document.createElement('div') dom.setAttribute('id', propKey) dom.innerHTML = value document.getElementById('app').appendChild(dom) &#125; return Reflect.set(target, propKey, value) &#125;&#125;)proxy.test1 = '测试文字1'proxy.test2 = '测试文字2'let number = 1setInterval(() =&gt; &#123; proxy.test = ` &lt;span&gt;测试文字：&lt;/span&gt; &lt;span style="font-size: 36px; font-weight: 900;"&gt;$&#123;number&#125;&lt;/span&gt; `; number++&#125;, 1000) 使用 handler.apply() 方法用于拦截函数的调用： 123456789101112function target(a, b) &#123; return a + b&#125;const proxy = new Proxy(target, &#123; apply(target, ctx, args) &#123; // ctx 为被调用时的上下文对象，args 为被调用时的参数数组 let [a, b] = args return a * b &#125;&#125;)console.log(proxy(2, 3)) // 6 适配器（Adapter）模式适配器的别名是包装器(wrapper)，它的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种 “亡羊补牢”的模式，没有人会在程序的设计之初就使用它。 123456789101112131415161718192021222324252627282930// 假设我们要实现一个渲染地图的功能，我们有如下格式的一组城市数据：const cityData = [ &#123; id: 1, name: 'beijing' &#125;, &#123; id: 2, name: 'shanghai' &#125;]// 同时我们有一个渲染地图的方法，但是上面的城市数据的格式不符合渲染地图方法所需的数据格式function renderMap(cityData) &#123; // 开始渲染地图 console.log(cityData)&#125;// 所以我们定义一个适配器模式的方法来将数据做一个转换function cityAdapter(oldCityData) &#123; const cityData = &#123;&#125; for (let city of oldCityData) &#123; cityData[city.name] = city.id &#125; return cityData&#125;// 使用renderMap(cityAdapter(cityData)) // &#123;beijing: 1, shanghai: 2&#125; 桥接（Bridge）模式桥接模式（Bridge）将抽象部分与实现部分解耦，使它们都可以独立地变化。同时如果系统沿着多个维度变化时，可以使用桥接模式降低抽象和实现两个可变维度的耦合度。 先来看一个不使用桥接模式点击修改页面文字颜色及字号的示例： 123456const colorDiv = document.getElementById('color')// 不使用桥接模式，实现部分与抽象部分深度耦合colorDiv.onclick = function(e) &#123; e.target.style.color = 'orange'&#125; 使用桥接模式： 1234567891011const colorDiv = document.getElementById('color')function changeStyle(el, type, fn) &#123; // 实现部分（这里我们把实现部分也做了抽象化，使之可以通过传入不同"type"实现鼠标点击、移入等多种操作） el[type] = fn&#125;function setStyle() &#123; // 抽象部分 this.style.color = 'orange'&#125;changeStyle(colorDiv, 'onclick', setStyle) 使用桥接模式后，增加了代码复杂度（缺点），但是将抽象部分与实现部分解耦，使其可以独立变化。 再看一个组装电脑的示例： 12345678910111213141516171819202122232425262728293031323334class CPU &#123; constructor(level) &#123; this.level = level &#125; run() &#123; console.log(`$&#123;this.level&#125;cpu开始工作`) &#125;&#125;class RAM &#123; constructor(level) &#123; this.level = level &#125; run() &#123; console.log(`$&#123;this.level&#125;内存开始工作`) &#125;&#125;class Computer &#123; constructor(cpuLevel, ramLevel) &#123; this.cpu = new CPU(cpuLevel) this.ram = new RAM(ramLevel) &#125; run() &#123; this.cpu.run() this.ram.run() &#125;&#125;const computer = new Computer('i7', '32G')computer.run() 这个示例包含CPU与RAM两个维度，我们通过桥接模式快速组合不同配置的CPU与RAM，降低了两个维度（CPU、RAM）与实现部分（组装电脑）的耦合度，使其可以独立变化。 装饰者（Decorator）模式在程序开发中，许多时候都并不希望某个类天生就非常庞大，一次性包含许多职责，那么我们就可以使用装饰者模式。装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。 装饰者模式通常可以应用在例如数据统计上报、插件式的表单验证等用途。 装饰者模式的简单实现例如，现在有一个需求要我们生产一辆红色的汽车： 123456789101112131415class Car &#123; init() &#123; console.info('生产了一辆汽车') this.setRedColor() &#125; setRedColor() &#123; console.info('将汽车设置为红色') &#125;&#125;const car = new Car()car.init()// 生产了一辆汽车// 将汽车设置为红色 如果后期需求变动为生产一辆蓝色的汽车，代码可能会变成这样： 12345678910111213141516171819class Car &#123; init() &#123; console.info('生产了一辆汽车') this.setBlueColor() &#125; setRedColor() &#123; console.info('将汽车设置为红色') &#125; setBlueColor() &#123; console.info('将汽车设置为蓝色') &#125;&#125;const car = new Car()car.init()// 生产了一辆汽车// 将汽车设置为蓝色 如果后期需求再变动为其他颜色，或者添加一个除颜色之外的其他属性时，生产不同的汽车就变得难以应对。 所以下面用装饰者模式来优化： 1234567891011121314151617181920212223242526272829303132333435class Car &#123; init() &#123; console.info('生产了一辆汽车') &#125;&#125;class setRedColor &#123; constructor(car) &#123; this.car = car &#125; init() &#123; this.car.init() console.info('将汽车设置为红色') &#125;&#125;class setLight &#123; constructor(car) &#123; this.car = car &#125; init() &#123; this.car.init() console.info('给汽车设置灯光') &#125;&#125;let car = new Car()car = new setRedColor(car)car = new setLight(car)car.init()// 生产了一辆汽车// 将汽车设置为红色// 给汽车设置灯光 优化后的代码使用了给对象动态添加职责的方式（设置颜色），并没有真正地改动对象自身（生产汽车），而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。这些对象都拥有相同的接口（ init 方法），当请求达到链中的某个对象时，这个对象会执行自身的操作，随后把请求转发给链中的下一个对象。 因为装饰者对象和它所装饰的对象拥有一致的接口，所以它们对使用该对象的客户来说是透明的，被装饰的对象也并不需要了解它曾经被装饰过，这种透明性使得我们可以递归地嵌套任意多个装饰者对象。 用 AOP 装饰函数例如现在有一个关机方法 shutdown ： 123function shutdown() &#123; console.info('正在关机…')&#125; 这时我们需要扩展该方法，在调用关机操作后输出关机时间。此时最简单粗暴的方法就是直接改写 shutdown 方法，但这样修改了原方法，不是很好的实现方式。于是我们用通过保存原方法的引用来扩展这个方法。 12345678910111213function shutdown() &#123; console.info('正在关机…')&#125;let _shutdown = shutdownshutdown = function() &#123; _shutdown() console.info(`关机时间：$&#123;new Date().toLocaleString()&#125;`)&#125;shutdown()// 正在关机…// 关机时间：2022/1/1 00:10:00 这样做使我们在增加新功能的时候没有修改原来的方法，但是这种方式依然存在两个问题： 多了一个需要维护的 _shutdown 变量 ，如果函数的装饰链较长或者需要装饰的函数变多，类似的变量也会变得更多。 会有 this 指向被劫持的情况。 所以这时我们用 AOP （面向切面编程 Aspect Oriented Programming）装饰函数来重新装饰该方法。 AOP 最常用的两种实现方式分别是切入到方法前和切入到方法后，下面看下实现代码： 12345678910111213141516Function.prototype.before = function(beforefn) &#123; const _this = this return function() &#123; beforefn.apply(this, arguments) return _this.apply(this, arguments) &#125;&#125;Function.prototype.after = function(afterfn) &#123; const _this = this return function() &#123; const result = _this.apply(this, arguments) afterfn.apply(this, arguments) return result &#125;&#125; 两个方法都接收一个函数作为参数，然后返回一个“代理”函数。利用 apply 方法确保 this 指向不被劫持，分别在原方法执行前后插入传入的自定义函数，并保证返回原函数一样的结果。 上面的 AOP 装饰函数是将两个方法分别挂载到 Function 的原型上来实现的，如果你不想用这种污染原型的方式，可以将原函数和新函数都作为参数传入两个方法中： 1234567891011121314function before(fn, beforefn) &#123; return function() &#123; beforefn.apply(this, arguments) return fn.apply(this, arguments) &#125;&#125;function after(fn, afterfn) &#123; return function() &#123; const result = fn.apply(this, arguments) afterfn.apply(this, arguments) return result &#125;&#125; 最后用两种方法分别来装饰 shutdown 方法： 1234567891011121314const beforeShutdown = shutdown.before(function() &#123; console.info(`关机时间：$&#123;new Date().toLocaleString()&#125;`)&#125;)const afterShutdown = shutdown.after(function() &#123; console.info(`关机时间：$&#123;new Date().toLocaleString()&#125;`)&#125;)beforeShutdown()// 关机时间：2022/1/1 00:10:00// 正在关机…afterShutdown()// 正在关机…// 关机时间：2022/1/1 00:10:00 使用 AOP 装饰函数有两个主要的特性： 可以使我们在不改动原函数的情况下将新函数插入到原函数中生成新的方法。 可以动态的改变函数的参数（因为在实现逻辑中，原函数与新函数共享 arguments 参数，所以给了我们改变参数的能力）。 装饰模式与代理模式的区别 代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代 理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。换句话说，代理模式强调一种关系(Proxy 与它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理 - 本体的引用，而装饰者模式经常会形成一条长长的装饰链。 –《JavaScript设计模式与开发实践》 外观（Facade）模式外观模式（Facade）也叫门面模式，它为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松地使用子系统。本质是封装交互，简化调用。 例如我们要封装一个给元素添加事件的方法，就可以用外观模式来做跨浏览器的兼容方案。 123456789101112131415function addEvent(el, type, fn) &#123; if (el.addEventListener) &#123; el.addEventListener(type, fn, false) &#125; else if (el.attachEvent) &#123; // &lt; IE9（IE5-IE10支持 attachEvent） el.attachEvent('on' + type, fn) &#125; else &#123; el['on' + type] = fn &#125;&#125;// 使用addEvent(document.getElementById('div'), 'click', function(e) &#123; var dom = e.target || e.srcElement; dom.style.color = 'orange'&#125;) 享元（Flyweight）模式享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。 先看一个例子： 假设有一家服装工厂，目前的产品有50种男性服装+50种女性服装，现在要分别为这100种服装拍照，工厂决定生产塑料模特来穿上服装拍照。 在不使用享元模式的情况下，需要生产100个塑料模特（100个model对象），代码如下： 12345678910111213141516171819class Model &#123; constructor(sex, underwear) &#123; this.sex = sex this.underwear = underwear &#125; takePhoto() &#123; console.log(`TakePhoto $&#123;this.sex&#125;, underwear $&#123;this.underwear&#125;`) &#125;&#125;for (let i = 1; i &lt;= 50; i++) &#123; const maleModel = new Model('male', i) maleModel.takePhoto()&#125;for (let i = 1; i &lt;= 50; i++) &#123; const femaleModel = new Model('female', i) femaleModel.takePhoto()&#125; 要得到一张照片，每次都需要传入 sex 和 underwear 两个参数，共创建了100个model对象。很显然实际并不需要生产100个塑料模特，只需要生产两个（一个男性一个女性）分别拍照即可。 改写代码如下： 123456789101112131415161718class Model &#123; constructor(sex) &#123; this.sex = sex &#125; takePhoto(underwear) &#123; console.log(`TakePhoto $&#123;this.sex&#125;, underwear $&#123;underwear&#125;`) &#125;&#125;const maleModel = new Model('male')for (let i = 1; i &lt;= 50; i++) &#123; maleModel.takePhoto(i)&#125;const femaleModel = new Model('female')for (let i = 1; i &lt;= 50; i++) &#123; femaleModel.takePhoto(i)&#125; 改写后的代码只生产了2个model对象，创建对象时只传入 sex 属性，underwear 则被抽离成外部参数，调用 takePhoto 方法时才传入使用。 上面的例子即是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性），例子中的内部状态为 sex ，外部状态为 underwear 。享元模式的目标是尽量减少共享对象的数量。 关于如何划分内部状态和外部状态： 内部状态存储于对象内部。 内部状态可以被一些对象共享。 内部状态独立于具体的场景，通常不会改变。 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。 在上面的例子中，不使用享元模式时，我们需要将所有状态（可以共享+不可共享）的组合组成一个个独立的对象，这在多个状态的情况下是不可行的，因为可能会组合出数量非常庞大的独立对象，所占用的内存也是非常大的。这时就可以使用享元模式来进行优化：剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间的优化模式。 组合（Composite）模式组合模式将对象组合成树形结构，以表示“部分 - 整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。 在组合模式中，请求在树中传递的过程总是遵循一种逻辑。如果子节点是叶对象，叶对象自身会处理这个请求，而如果子节点还是组合对象，请求会继续往下传递。请求从上到下沿着树进行传递，直到树的尽头。作为客户，只需要关心树最顶层的组合对象，客户只需要请求这个组合对象，请求便会沿着树往下传递，依次到达所有的叶对象。 组合模式示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Folder &#123; constructor(name) &#123; this.name = name this.fileList = [] &#125; add(file) &#123; this.fileList.push(file) &#125; read() &#123; console.log(`开始读取文件夹: $&#123;this.name&#125;`) if (this.fileList.length === 0) &#123; console.log(`$&#123;this.name&#125;: &lt;空&gt;`) return &#125; for (let i = 0; this.fileList[i]; i++) &#123; this.fileList[i].read() &#125; &#125;&#125;class File &#123; constructor(name) &#123; this.name = name &#125; add() &#123; throw new Error('叶对象不能添加子节点') &#125; read() &#123; console.log(`开始读取文件: $&#123;this.name&#125;`) &#125;&#125;const folder = new Folder('folder')const folder1 = new Folder('folder1')const folder2 = new Folder('folder2')const file1 = new File('file1')const file2 = new File('file2')const file3 = new File('file3')folder.add(folder1)folder1.add(file1)folder1.add(file2)folder1.add(folder2)folder.add(file3)folder.read()// 输出:// 开始读取文件夹: folder// 开始读取文件夹: folder1// 开始读取文件: file1// 开始读取文件: file2// 开始读取文件夹: folder2// folder2: &lt;空&gt;// 开始读取文件: file3 以上示例包含 Folder 和 File 两个类，分别代表文件夹和文件。他们都有 name 属性表示自己的名称，文件夹有一个 fileList 属性用来存储自己内部的文件。两者都提供了 read 读取方法，文件夹的读取方法表示读取自己内部的文件，而文件的 read 方法用来读取自身。文件夹还提供了一个 add 方法用来将文件添加到自己的文件列表内。 文件和文件夹之间的关系，非常适合用组合模式来描述。文件夹里既可以包含文件，又可以包含其他文件夹，最终可能组合成一棵树。当调用 folder.read() 方法时，请求从树最顶端的对象往下传递，如果当前处理请求的对象是叶对象，叶对象自身会对请求作出相应的处理；如果当前处理请求的对象是组合对象，组合对象则会遍历它属下的子节点，将请求继续传递给这些子节点。 需要注意的点 组合模式不是父子关系 组合模式是一种聚合的关系。组合对象包含一组叶对象，但叶对象并不是组合对象的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口，但实际上它们并非真正意义上的父子关系。 对叶对象操作的一致性 只有用一致的方式对待列表中的每个叶对象的时候，才适合使用组合模式。 双向映射关系 某些情况下叶对象可能从属于多个组合对象，或者叶对象某些功能的实现需要依赖组合对象，这时我们需要给组合对象与叶对象建立双向映射的关系来实现某些功能（如下面删除文件/文件夹的功能）。 建立双向映射关系如果这时要给文件/文件夹添加删除方法，在调用时实际上是从这个文件/文件夹所在的上层文件夹中删除的，所以此时组合对象与叶对象之间建立双向映射关系就是必要的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Folder &#123; constructor(name) &#123; this.name = name this.fileList = [] this.parent = null &#125; add(file) &#123; file.parent = this // 设置父对象 this.fileList.push(file) &#125; read() &#123; console.log(`开始读取文件夹: $&#123;this.name&#125;`) if (this.fileList.length === 0) &#123; console.log(`$&#123;this.name&#125;: &lt;空&gt;`) return &#125; for (let i = 0; this.fileList[i]; i++) &#123; this.fileList[i].read() &#125; &#125; remove() &#123; if (!this.parent) &#123; // 根节点或者树外的游离节点 return &#125; for (let i = 0; i &lt; this.parent.fileList.length; i++) &#123; const file = this.parent.fileList[i] if (file === this) &#123; console.log(`删除文件夹: $&#123;file.name&#125;`) this.parent.fileList.splice(i, 1) break &#125; &#125; &#125;&#125;class File &#123; constructor(name) &#123; this.name = name this.parent = null &#125; add() &#123; throw new Error('叶对象不能添加子节点') &#125; read() &#123; console.log(`开始读取文件: $&#123;this.name&#125;`) &#125; remove() &#123; if (!this.parent) &#123; // 根节点或者树外的游离节点 return &#125; for (let i = 0; i &lt; this.parent.fileList.length; i++) &#123; const file = this.parent.fileList[i] if (file === this) &#123; console.log(`删除文件: $&#123;file.name&#125;`) this.parent.fileList.splice(i, 1) break &#125; &#125; &#125;&#125;const folder = new Folder('folder')const folder1 = new Folder('folder1')const folder2 = new Folder('folder2')const file1 = new File('file1')const file2 = new File('file2')const file3 = new File('file3')folder.add(folder1)folder1.add(file1)folder1.add(file2)folder1.add(folder2)folder.add(file3)folder2.remove()file2.remove()folder.read()// 输出:// 删除文件夹: folder2// 删除文件: file2// 开始读取文件夹: folder// 开始读取文件夹: folder1// 开始读取文件: file1// 开始读取文件: file3 以上代码给文件夹和文件类中分别加入了一个 parent 属性来保存其父文件夹的引用，又为它们各自添加了一个 remove 方法用来删除自身。当它们被某个文件夹调用 add 方法添加时，会把自己的 parent 属性指向该文件夹，这样调用自己的 remove 方法时就可以遍历自己父文件夹的文件列表，找到自身后将其移除。 何时使用组合模式组合模式如果运用得当，可以大大简化客户的代码。一般来说，组合模式适用于以下这两种情况： 表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后，只需要通过请求树的最顶层对象，便能对整棵树做统一的操作。在组合模 式中增加和删除树的节点非常方便，并且符合开放-封闭原则。 客户希望统一对待树中的所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就不用写一堆 if、else 语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这是组合模式最重要的能力。 《JavaScript设计模式与开发实践》 模板方法（Template Method）模式模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类。 模板方法示例假如我们现在要冲泡一杯咖啡，有如下四个步骤： 把水煮沸 用沸水冲泡咖啡 把咖啡倒进杯子 加牛奶 1234567891011121314151617181920212223242526272829303132class Coffee &#123; boilWater() &#123; console.log('把水煮沸') &#125; brew() &#123; console.log('用沸水冲泡咖啡') &#125; pourInCup() &#123; console.log('把咖啡倒进杯子') &#125; addMilk() &#123; console.log('加牛奶') &#125; init() &#123; this.boilWater() this.brew() this.pourInCup() this.addMilk() &#125;&#125;const coffee = new Coffee()coffee.init()// 把水煮沸// 用沸水冲泡咖啡// 把咖啡倒进杯子// 加牛奶 如果现在又要冲泡一杯柠檬茶，也有四个步骤： 把水煮沸 用沸水冲泡茶叶 把茶水倒进杯子 加柠檬 冲咖啡与冲茶步骤类似，主要的制作区别在第2步与第4步。所以这时我们可以使用模板方法模式，来创建一个 Beverage 类来指代饮料，分别用继承的方式创建 Coffee 与 Tea 用作冲泡咖啡与茶。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Beverage &#123; boilWater() &#123; console.log('把水煮沸') &#125; brew() &#123; throw new Error('子类必须重写 brew 方法') &#125; pourInCup() &#123; console.log('倒进杯子') &#125; addCondiment() &#123; throw new Error('子类必须重写 addCondiment 方法') &#125; // 钩子方法 isNeedCondiment() &#123; return false &#125; init() &#123; this.boilWater() this.brew() this.pourInCup() if (this.isNeedCondiment()) &#123; this.addCondiment() &#125; &#125;&#125;class Coffee extends Beverage &#123; brew() &#123; console.log('用沸水冲泡咖啡') &#125; addCondiment() &#123; console.log('加牛奶') &#125; isNeedCondiment() &#123; return true &#125;&#125;class Tea extends Beverage &#123; brew() &#123; console.log('用沸水冲泡茶叶') &#125; addCondiment() &#123; console.log('加柠檬') &#125; isNeedCondiment() &#123; return true &#125;&#125;const coffee = new Coffee()coffee.init()const tea = new Tea()tea.init()// 把水煮沸// 用沸水冲泡咖啡// 倒进杯子// 加牛奶// 把水煮沸// 用沸水冲泡茶叶// 倒进杯子// 加柠檬 上面的代码我们首先创建了一个抽象类 Beverage ，该类中的前四个方法提供了制作饮料需要的四个步骤。其中 brew 和 addCondiment 方法为抽象方法，继承的子类必须提供对应的方法来覆盖（如果需要加调料的话），否则会抛错提醒。boilWater 和 pourInCup 方法继承的子类可以提供以覆盖默认行为或者不提供。同时我们还新增了一个钩子方法 isNeedCondiment 来让子类选择是否添加调料，默认行为是不添加。 让我们来统计一下上面代码中出现的各种类和方法： 抽象类：Beverage 抽象方法：brew 、addCondiment 具体类：Coffee、Tea 具体方法：boilWater 、pourInCup 钩子方法（hook）：isNeedCondiment 模板方法：init 最终，我们调用模板方法 init 来制作了两杯饮料（咖啡和柠檬茶）。这个方法规定了子类的算法和框架，它作为一个算法的模板，指导子类以何种顺序去执行哪些方法。 在传统面向对象的语言中（如Java），我们可以创建不能被实例化的抽象类，用于规定实现子类的框架和算法，这个抽象类一定是用来被某些具体类继承的。而在JavaScript中，没有抽象类的概念，所以我们用以上的形式模拟抽象类的实现，也能达到相应的目的。 在JavaScript中，我们很多时候都不需要依样画瓢（使用抽象类与继承）地去实现一个模版方法模式，高阶函数是更好的选择。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const Beverage = function(param) &#123; const boilWater = function() &#123; console.log('把水煮沸') &#125; const brew = param.brew || function() &#123; throw new Error('必须传递 brew 方法') &#125; const pourInCup = function() &#123; console.log('倒进杯子') &#125; const addCondiment = param.addCondiment || function() &#123; throw new Error('必须传递 addCondiment 方法') &#125; const F = function() &#123;&#125; F.prototype.init = function() &#123; boilWater() brew() pourInCup() addCondiment() &#125; return F&#125;const Tea = Beverage(&#123; brew() &#123; console.log('用沸水冲泡茶叶') &#125;, addCondiment() &#123; console.log('加柠檬') &#125;&#125;)const tea = new Tea()tea.init()// 把水煮沸// 用沸水冲泡茶叶// 倒进杯子// 加柠檬 好莱坞原则 “不要给我们打电话，我们会给你打电话(don‘t call us, we‘ll call you)”这是著名的好莱坞原则。在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项的完全控制，演员只能被动式的接受公司的差使，在需要的环节中，完成自己的演出。 模板方法模式是好莱坞原则的一个典型使用场景。用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。 除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。 解释器（Interpreter）模式定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器。这个解释器使用该表示来解释语言中的句子。 日常见到的解释器： 正则表达式：它就是解释器模式的一种应用，解释器会根据正则表达式的固定文法，去对一个正则表达式进行解释。 代码解释器：负责解释并执行代码逻辑。（注意：这里代码解释器与编译器有所不同，解释器不会对代码进行编译转换，仅仅是解释执行，而编译器会把源文件转换成另外一种形式的代码，不会执行代码逻辑） 日常开发中基本不会用到解释器模式。 解释器模式通常由 AbstractExpression （抽象语法表达式）、TerminalExpression （终结符）与NonterminalExpression （非终结符）组成。 调用时遇到非终结符则继续调用，只有终结符才能直接判断。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 抽象类，终结符与非终结符都继承自该类并实现各自的 interpret 方法class AbstractExpression &#123; interpret() &#123;&#125;&#125;// 终结符表达式class TerminalExpression extends AbstractExpression &#123; constructor(values) &#123; super() this.values = values // 计算范围Array &#125; interpret(value) &#123; return this.values.includes(value) // 值必须在values范围内包含 &#125;&#125;// 非终结符表达式class NonterminalExpression extends AbstractExpression &#123; constructor(left, right) &#123; super() this.left = left this.right = right &#125; interpret(value) &#123; value = value.replace(/\s*/g, '') // 去除字符串内所有空格 if (!value.includes('+')) &#123; return new Error('必须包含+号') &#125; const [value1, value2] = value.split('+') return this.left.interpret(value1) &amp;&amp; this.right.interpret(value2) ? Number(value1) + Number(value2) : new Error('参数不在计算范围内') &#125;&#125;const range = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'] // 计算参数范围const terminal = new TerminalExpression(range)const add = new NonterminalExpression(terminal, terminal)add.interpret('3 + 5') // 8add.interpret('2 + 10') // 12add.interpret('3 - 1') // Error: 必须包含"+"号add.interpret('3 + 11') // Error: 参数不在计算范围内 解释器将复杂语法解析抽象为一个个独立的终结符与非终结符各自判断，只要每个文法自己的判断做好了，剩下的工作就是组装文法。 这种将单个逻辑判断与文法组装解耦的做法，可以使逻辑判断与文法组装独立变换，使复杂语法解析转化为一个个具体的简单问题。 上述代码只是对单一示例的简单实现，实际上在实现一个解释器的时候，往往会涉及到编译原理相关的知识。 策略（Strategy）模式策略模式指的是定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 “并且使它们可以相互替换”，这句话在很大程度上是相对于静态类型语言而言的。因为静态类型语言中有类型检查机制，所以各个策略类需要实现同样的接口。当它们的真正类型被隐藏在接口后面时，它们才能被相互替换。而在 JavaScript 这种“类型模糊”的语言中没有这种困扰，任何对象都可以被替换使用。因此，JavaScript 中的“可以相互替换使用”表现为它们具有相同的目标和意图。 假如我们需要实现一个计算券后价格的方法，该方法通过传入原价与优惠券来计算享受了优惠券折扣后的商品价格。 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。 1234567891011function calculatePrice(price, coupon) &#123; if (coupon === 'A') &#123; return price * 0.9 &#125; else if (coupon === 'B') &#123; return price * 0.8 &#125; else if (coupon === 'C') &#123; return price * 0.7 &#125; else &#123; return price &#125;&#125; 使用策略模式重构方法12345678910111213141516171819202122232425262728293031323334353637383940class CouponA &#123; calculatePrice(price) &#123; return price * 0.9 &#125;&#125;class CouponB &#123; calculatePrice(price) &#123; return price * 0.8 &#125;&#125;class CouponC &#123; calculatePrice(price) &#123; return price * 0.7 &#125;&#125;class Goods &#123; constructor() &#123; this.price = null // 商品原价 this.strategy = null // 优惠券对应的策略对象 &#125; setPrice(price) &#123; this.price = price &#125; setStrategy(strategy) &#123; this.strategy = strategy &#125; // 获取券后优惠券价格 getDiscountPrice() &#123; return this.strategy.calculatePrice(this.price) &#125;&#125;const goods = new Goods()goods.setPrice(10)goods.setStrategy(new CouponB())goods.getDiscountPrice() // 8 以上代码使用了策略模式，定义一系列的算法，把它们各自封装成策略类CouponA、CouponB、CouponC ，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些策略对象中间的某一个进行计算。 通过策略模式重构之后，代码变得更加清晰，各个类的职责更加鲜明。但这段代码是基于传统面向对象语言的模仿，下面我们用 JavaScript 来实现策略模式。 JavaScript版本的策略模式在 JavaScript 中，函数也是对象，所以更简单和直接的做法是把 strategy 直接定义为函数： 123456789101112131415161718const strategies = &#123; 'A': function(price) &#123; return price * 0.9 &#125;, 'B': function(price) &#123; return price * 0.8 &#125;, 'C': function(price) &#123; return price * 0.7 &#125;&#125;const calculatePrice = function(coupon, price) &#123; return strategies[coupon](price)&#125;calculatePrice('A', 10) // 9calculatePrice('B', 10) // 8 实际上在 JavaScript 这种将函数作为一等对象的语言里，策略模式已经融入到了语言本身当中，我们经常用高阶函数来封装不同的行为，并且把它传递到另一个函数中。当我们对这些函数发出“调用”的消息时，不同的函数会返回不同的执行结果。 通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。所有跟计算价格有关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 并没有计算价格的能力，而是把这个职责委托给了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。当我们对这些策略对象发出“计算价格”的请求时，它们会返回各自不同的计算结果，这正是对象多态性的体现，也是“它们可以相互替换”的目的。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。 从定义上看，策略模式就是用来封装算法的。但在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。策略模式一般也会被用来实现表单校验等功能。 策略模式的优缺点 优点 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，易于理解，易于扩展。 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。 缺点 使用策略模式会在程序中增加许多策略类或者策略对象。（但实际上这比把它们负责的逻辑堆砌在 Context 中要好） 要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy。 命令（Command）模式命令模式中的命令(command)指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 下面来看一个具体的实例：现在有2个按钮，我们需要给两个按钮填充对应的功能。绘制按钮与填充功能分别由不同的人进行开发，这时使用命令模式就变得非常合理。绘制按钮的人需要在按钮点击的时候向某些对象发送请求，但是不需要关心请求的接收者是谁，也不需要知道被请求的操作是什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const button1 = document.getElementById('button1')const button2 = document.getElementById('button2')// 发布者对象（负责定义安装命令的接口）const setCommand = function(button, command) &#123; button.onclick = function() &#123; command.execute() &#125;&#125;// 接收者对象（负责具体执行）const MenuObj = &#123; refresh: function() &#123; console.log('刷新页面') &#125;, back: function() &#123; console.log('后退') &#125;&#125;// 命令对象（负责暴露出统一的调用方法给发布者对象，并且去调用接收者对象的命令）class RefreshCommand &#123; constructor(receiver) &#123; this.receiver = receiver &#125; execute() &#123; this.receiver.refresh() &#125;&#125;class BackCommand &#123; constructor(receiver) &#123; this.receiver = receiver &#125; execute() &#123; this.receiver.back() &#125;&#125;const refreshCommand = new RefreshCommand(MenuObj)const backCommand = new BackCommand(MenuObj)setCommand(button1, refreshCommand)setCommand(button2, backCommand) 上面代码使用命令模式为两个按钮分别填充了各自的功能，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。这里使用了3个角色来实现功能： 发布者对象：请求的发起者，不关心接收者是谁，也不知道接收者会做什么，通过命令对象进行调用。 接收者对象：负责接收与具体执行的对象，拥有执行命令接口。不关心也不知道谁发出的命令。 命令对象：暴露统一接口给发布者，并且负责去调用接收者接口的对象。充当发布者与接收者之间的桥梁，实现发布者与接收者之间的解耦。 JavaScript中的命令模式以上代码是模拟传统面向对象语言的命令模式实现。命令模式的由来，其实是回调(callback)函数的一个面向对象的替代品。JavaScript 作为将函数作为一等对象的语言，运算块不一定要封装在 command.execute 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。 12345678910111213141516171819202122232425262728293031323334353637383940const button1 = document.getElementById('button1')const button2 = document.getElementById('button2')// 发布者对象（负责定义安装命令的接口）const setCommand = function(button, command) &#123; button.onclick = function() &#123; command.execute() &#125;&#125;// 接收者对象（负责具体执行）const MenuObj = &#123; refresh: function() &#123; console.log('刷新页面') &#125;, back: function() &#123; console.log('后退') &#125;&#125;// 命令对象（负责暴露出统一的调用方法给发布者对象，并且去调用接收者对象的命令）const RefreshCommand = function(receiver) &#123; return &#123; // 这里也可以直接返回函数供发布者对象使用，但是为了将来提供其他操作（如撤销命令等操作），所以返回一个包含操作的对象 execute: function() &#123; receiver.refresh() &#125; &#125;&#125;const BackCommand = function(receiver) &#123; return &#123; execute: function() &#123; receiver.back() &#125; &#125;&#125;const refreshCommand = new RefreshCommand(MenuObj)const backCommand = new BackCommand(MenuObj)setCommand(button1, refreshCommand)setCommand(button2, backCommand) 命令模式实现撤销和重做命令对象的作用除了可以给发布者暴露接口和调用接收者对象之外，还可以很方便的记录执行历史，从而实现撤销和重做功能。 下面的代码我将用之前写过的小程序电子签名组件为例，来为其加入撤销和重做功能。 首先是基本的绘制功能，实现原理很简单，只需要在小程序的 canvas 组件中监听手指触摸动作开始 bindtouchstart 和手指触摸后移动 bindtouchmove 两个事件，从回调函数中取到相应的坐标用小程序为我们提供的 Canvas 2D 相关 api 进行绘制即可。这里我们用 Sign 类来封装相关的代码，Sign 类在这里充当的是接收者对象的角色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// sign.js/** * @description: 电子签名组件（wxml页面内需要提供id="signCanvas"的canvas画布） * 使用方式： * 1. const signInstance = new Sign() // 实例化组件 * 2. signInstance.initCanvas() // 调用组件初始化方法 * 3. signInstance.draw(config) // 调用绘制方法 */export default class Sign &#123; constructor() &#123; this.canvas = null; // Canvas对象 this.ctx = null; // Canvas 绘制上下文 &#125; // 初始化Canvas画布 initCanvas() &#123; return new Promise(resolve =&gt; &#123; wx.createSelectorQuery() .select("#signCanvas") .fields(&#123; node: true, size: true &#125;) .exec(res =&gt; &#123; this.canvas = res[0].node; this.ctx = this.canvas.getContext("2d"); const &#123; canvas, ctx &#125; = this; const dpr = wx.getSystemInfoSync().pixelRatio; canvas.width = res[0].width * dpr; canvas.height = res[0].height * dpr; ctx.scale(dpr, dpr); // 设置画布背景色 ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height); resolve(); &#125;); &#125;); &#125; /** * @description: 绘制 * @param &#123;Number&#125; config.startX 起始x坐标 * @param &#123;Number&#125; config.startY 起始y坐标 * @param &#123;Number&#125; config.moveX 要移动到的x点坐标 * @param &#123;Number&#125; config.moveY 要移动到的y点坐标 */ draw(config = &#123;&#125;) &#123; const &#123; startX, startY, moveX, moveY &#125; = config; if (startX || startY) &#123; this.ctx.moveTo(startX, startY); &#125; if (moveX || moveY) &#123; this.ctx.lineWidth = 2; // 设置线条宽度 this.ctx.lineTo(moveX, moveY); this.ctx.stroke(); this.ctx.moveTo(moveX, moveY); &#125; &#125;&#125; 上面的接收者对象提供了 initCanvas 方法用来初始化画布，draw 方法用来绘制。 接下来我们实现 SignCommand 类，即命令对象。这个对象里调用了接收者对象 Sign ，并向外部暴露了 execute 执行、撤销 prev 和重做 next 等方法。同时还在自身内部维护了绘制历史 history 对象，这是我们实现撤销和重做功能的关键（因为canvas很难实现上一步的操作，所以这里我们使用保存绘制历史重新绘制的方式实现撤销功能）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// signCommand.jsimport Sign from "@/utils/sign.js"; // 电子签名组件（接收者对象）// 电子签名命令对象（命令对象）export default class SignCommand &#123; /** * @param &#123;Object&#125; page 页面this实例 * @param &#123;Object&#125; receiver 电子签名对象（在这里是接收者对象） */ constructor(page, receiver) &#123; this.page = page; // 指向页面this this.receiver = receiver; // 签名组件实例 this.history = []; // 步骤历史数组 this.step = 0; // 当前所在的步骤数 this.history_item_cache = []; // 用来存放每一步历史记录的临时缓存 this.init(); &#125; /** * @description: 初始化/重置画布 */ init() &#123; this.receiver.initCanvas(); this.history = []; this.step = 0; this.history_item_cache = []; this._updatePageStep(); &#125; /** * @description: 执行命令（绘制） * @param &#123;Number&#125; config.startX 起始x坐标 * @param &#123;Number&#125; config.startY 起始y坐标 * @param &#123;Number&#125; config.moveX 要移动到的x点坐标 * @param &#123;Number&#125; config.moveY 要移动到的y点坐标 */ execute(config = &#123;&#125;) &#123; const &#123; touchEnd &#125; = config; if (touchEnd) &#123; this.step++; if (this.history_item_cache.length &gt; 0) &#123; this.history.push(this.history_item_cache); this.history_item_cache = []; &#125; this._updatePageStep(); return; &#125; this.receiver.draw(config); // 将绘画步骤添加到历史记录中并设置为最后一步 const &#123; startX, startY, moveX, moveY &#125; = config; if (startX || startY || moveX || moveY) &#123; this.history = this.history.slice(0, this.step); this.history_item_cache.push(&#123; startX, startY, moveX, moveY, &#125;); &#125; &#125; /** * @description: 上一步（撤销） */ async prev() &#123; if (this.step === 0 || this.history.length === 0) return; this.step--; this._updatePageStep(); await this.receiver.initCanvas(); for (let i = 0; i &lt; this.step; i++) &#123; this.history[i].forEach(item =&gt; &#123; this.receiver.draw(item); &#125;); &#125; &#125; /** * @description: 下一步（重做） */ async next() &#123; if (this.step === this.history.length) return; this.step++; this._updatePageStep(); await this.receiver.initCanvas(); for (let i = 0; i &lt; this.step; i++) &#123; this.history[i].forEach(item =&gt; &#123; this.receiver.draw(item); &#125;); &#125; &#125; /** * @description: 更新页面步骤信息 */ _updatePageStep() &#123; this.page.setData(&#123; currentStep: this.step, historyLength: this.history.length, &#125;); &#125; /** * @description: 保存签名图片至相册 */ save() &#123; // 该方法内包含检查用户相册权限、将画布内容转化为图片等功能，不在本次讨论范围内，暂且不占用篇幅列出 console.log('保存成功') &#125;&#125; 到这里我们的代码已经实现了撤销和重做的相关功能，只需要在小程序页面里调用即可。这里并没有封装通用的发布者对象，在小程序里每个相应的事件方法都充当了发布者（并非传统意义上的发布者对象，在这里只是起到了执行命令的作用）的角色。 职责链（Chain of Responsibility）模式职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 此时我们有3个方法：f1 、f2 、f3 ，这3个方法通过接收不同的参数来处理各自的请求。我们想用职责链模式来包装这3个方法，使其能够按照顺序选择处理请求，过程如下： 第1个方法接收到参数后，判断是否该交由自己处理，如果自己可以处理，处理完成并返回结果，如果自己处理不了，交由第2个方法处理（此时我们约定如果自己处理不了则返回一个特定的字符串 nextSuccessor 表示需要往后传递），以此类推。 这3个方法我们暂时省略参数及判断和处理过程。 1234567891011function f1() &#123; return 'nextSuccessor'&#125;function f2() &#123; return 'nextSuccessor'&#125;function f3() &#123; return 'done' // 表示处理结束，返回结果&#125; 接下来我们定义职责链包装方法： 1234567891011121314151617181920class Chain &#123; constructor(fn) &#123; this.fn = fn // 当前节点 this.successor = null // 表示职责链中的下一个节点 &#125; // 设置职责链中的下一个节点 setNextSuccessor(successor) &#123; return this.successor = successor &#125; // 传递请求给某个节点 passRequest() &#123; const result = this.fn.apply(this, arguments) if (result === 'nextSuccessor') &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments) &#125; return result &#125;&#125; 最后我们把3个方法分别包装成职责链的节点并将请求参数传入第一个节点： 12345const p1 = new Chain(f1), p2 = new Chain(f2), p3 = new Chain(f3) // 用职责链模式包装p1.setNextSuccessor(p2).setNextSuccessor(p3) // 指定职责链中节点的下一个节点p1.passRequest(params) // done// 这里我们的3个方法省略了内部的判断及处理过程，返回结果总是固定的，实际上是会在方法内部对传入的params进行判断处理 职责链中的节点 p1 接收到参数后，无法处理，将请求向后传递，最终由 p3 处理完成后返回了结果 done 。 以上只是抽象的列举了职责链模式的实现方法，实际开发中可以将职责链中的各个节点替换为业务中的方法，如根据不同活动类型、库存等条件计算活动价格等。 用 AOP 实现职责链12345678910111213141516171819202122232425function f1() &#123; return 'nextSuccessor'&#125;function f2() &#123; return 'nextSuccessor'&#125;function f3() &#123; return 'done' // 表示处理结束，返回结果&#125;Function.prototype.after = function(fn) &#123; const self = this return function() &#123; const result = self.apply(this, arguments) if (result === 'nextSuccessor') &#123; return fn.apply(this, arguments) &#125; return result &#125;&#125;const chain = f1.after(f2).after(f3)chain() // done 用 AOP 来实现职责链既简单又巧妙，但这种把函数叠在一起的方式，同时也叠加了函数的作用域，如果链条太长的话，也会对性能有较大的影响。 异步的职责链我们在上面的代码中实现职责链模式时，让每个节点都返回一个特定的值 nextSuccessor 来表示是否把请求传递给下一个节点。在实际开发中，节点有可能是执行了某些异步操作后才能返回结果，这时就行不通了。所以我们给 Chain 类再增加一个 next 方法，用于手动传递请求给职责链中的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function f1() &#123; console.log('f1') setTimeout(() =&gt; &#123; this.next() &#125;, 1000)&#125;function f2() &#123; console.log('f2') return 'done'&#125;function f3() &#123; console.log('f3') return 'done'&#125;class Chain &#123; constructor(fn) &#123; this.fn = fn this.successor = null &#125; setNextSuccessor(successor) &#123; return this.successor = successor &#125; next() &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments) &#125; passRequest() &#123; const result = this.fn.apply(this, arguments) if (result === 'nextSuccessor') &#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments) &#125; return result &#125;&#125;const p1 = new Chain(f1), p2 = new Chain(f2), p3 = new Chain(f3)p1.setNextSuccessor(p2).setNextSuccessor(p3)p1.passRequest()// 输出：f1// 1秒后输出：f2// 此时执行结束，没有继续向后传递，因为在f2中既没有手动调用next方法，也没有返回'nextSuccessor' 现在我们得到了一个节点有权决定什么时候把请求交给下一个节点的特殊链条。 职责链模式的优缺点 优点 解耦了请求发送者和N个接收者之间的复杂关系（由于不知道链中的哪个节点可以处理你发出的请求，所以你只需要把请求传递给第一个节点即可）。 使用了职责链模式后，链中的节点对象可以灵活地拆分重组。 可以手动指定起始节点，请求不是必须从链中的第一个节点开始传递（在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个 if 判断）。 缺点 我们无法保证某个请求一定会被链中的节点处理。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。 从性能方面考虑，我们要避免过长的职责链带来的性能损耗。 状态（State）模式状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。从它的定义中可以看出，状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。 接下来我们看一个示例： 假设我们现在要实现一个灯光程序，灯光有红、绿、黄三种颜色，初始状态为红色，每次点击按钮按照顺序切换一种： 123456789101112131415161718192021222324252627282930313233343536class Light &#123; constructor() &#123; this.light = null this.lightDom = null &#125; init() &#123; const self = this this.light = 'red' this.lightDom = document.createElement('div') this.lightDom.innerHTML = 'red' // 设置初始状态 const buttonDom = document.createElement('button') buttonDom.innerHTML = '切换' buttonDom.onclick = function() &#123; self.clickButton.call(self) &#125; document.body.appendChild(this.lightDom) document.body.appendChild(buttonDom) &#125; clickButton() &#123; if (this.light === 'red') &#123; this.light = 'green' &#125; else if (this.light === 'green') &#123; this.light = 'yellow' &#125; else &#123; this.light = 'red' &#125; this.lightDom.innerHTML = this.light &#125;&#125;const light = new Light()light.init() 这样实现非常简单，我们在 Light 类的内部声明了一个 light 属性来保存当前灯的状态（即颜色），再点击按钮时根据这个状态来决定下一步的行为。 但使用这种方式是违反开放-封闭原则的，每次新增或者修改灯光状态时，都要改动 clickButton 方法中的代码，这使得 clickButton 成为了一个非常不稳定的方法，而且随着后期灯光新增的颜色越来越多，这个方法会逐渐膨胀。如果我们想在 red 和 green 中间插入一种新的颜色，那么就需要改动后面的所有 if else 语句，这样会使 clickButton 更加难以阅读和维护。最后如果一个开发者想了解这个灯一共有多少种颜色，需要完整的阅读 clickButton 内的所有代码，不够一目了然。 状态模式的使用那么现在我们用状态模式来改进一下上面的代码。通常我们谈到封装，一般都会优先封装对象的行为，而不是对象的状态。但在状态模式中刚好相反，状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部，所以 button 被按下的的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。同时我们还可以把状态的切换规则事先分布在状态类中，这样就有效地消除了原本存在的大量条件分支语句。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class RedLight &#123; constructor(light) &#123; this.light = light this.state = 'red' &#125; clickButton() &#123; this.light.setState(this.light.greenLight) &#125;&#125;class GreenLight &#123; constructor(light) &#123; this.light = light this.state = 'green' &#125; clickButton() &#123; this.light.setState(this.light.yellowLight) &#125;&#125;class YellowLight &#123; constructor(light) &#123; this.light = light this.state = 'yellow' &#125; clickButton() &#123; this.light.setState(this.light.redLight) &#125;&#125;class Light &#123; constructor() &#123; this.currentLight = null this.lightDom = null this.redLight = new RedLight(this) this.greenLight = new GreenLight(this) this.yellowLight = new YellowLight(this) &#125; init() &#123; const self = this this.currentLight = this.redLight // 设置初始状态 this.lightDom = document.createElement('div') this.lightDom.innerHTML = this.currentLight.state const buttonDom = document.createElement('button') buttonDom.innerHTML = '切换' buttonDom.onclick = function() &#123; self.currentLight.clickButton.call(self.currentLight) &#125; document.body.appendChild(this.lightDom) document.body.appendChild(buttonDom) &#125; setState(newState) &#123; this.currentLight = newState this.lightDom.innerHTML = this.currentLight.state &#125;&#125;const light = new Light()light.init() 上面的代码我们通过状态模式实现了一样的输出效果。再回顾一下状态模式的定义： 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 我们以逗号分割，把这句话分为两部分来看。第一部分的意思是把不同颜色的灯光封装成了独立的类，并将请求委托给当前的状态对象，当对象的内部状态（this.light.currentLight）改变时，会带来不同的行为变化。第二部分是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。 使用了状态模式以后，之前提到的问题似乎大部分都被解决了。 状态模式中的性能优化点 有两种选择来管理 state 对象的创建和销毁。第一种是仅当 state 对象被需要时才创建并随后销毁，另一种是一开始就创建好所有的 state 对象，并且始终不销毁它们。如果 state 对象比较庞大，可以采用第一种方式来节省内存。但如果 state 对象切换比较频繁，可以一开始就把这些 state 对象都创建出来，也没有必要销毁它们，因为可能很快将再次用到它们。 在上面的例子中，我们为每个 Content 对象都创建了一组 state 对象，实际上各 Content 对象可以共享一个 state 对象，可以搭配享元模式来优化它。 状态模式和策略模式的关系状态模式和策略模式都封装了一系列的算法或者行为，看起来很像，但在意图上有很大不同。二者相同点是它们都有一个上下文、一些策略或者状态类，上下文把请求委托给这些类来执行。区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法；而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，“改变行为”这件事情发生在状态模式内部。对客户来说，并不需要了解这些细节。这正是状态模式的作用所在。 状态模式的优缺点 优点 态模式定义了状态与行为之间的关系，并将它们封装在一个类里。通过增加新的状态类，很容易增加新的状态和转换。 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中，也去掉了 Context 中原本过多的条件分支。 Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 缺点 状态模式需要定义多个类，是一项枯燥乏味的工作，而且系统中会因此而增加不少对象。 由于逻辑是分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。 有限状态机状态模式是状态机的实现之一。有限状态机有如下三个特点： 状态总数是有限的。 任意时刻，只会处于某一个状态中。 某种条件下，会从一种状态转换到另一种状态。 我们还是来实现一个上面灯光程序的有限状态机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const FSM = &#123; redLight: &#123; clickButton() &#123; this.lightDom.innerHTML = 'green' this.currentLight = FSM.greenLight &#125; &#125;, greenLight: &#123; clickButton() &#123; this.lightDom.innerHTML = 'yellow' this.currentLight = FSM.yellowLight &#125; &#125;, yellowLight: &#123; clickButton() &#123; this.lightDom.innerHTML = 'red' this.currentLight = FSM.redLight &#125; &#125;&#125;class Light &#123; constructor() &#123; this.currentLight = null this.lightDom = null &#125; init() &#123; const self = this this.currentLight = FSM.redLight // 设置初始状态 this.lightDom = document.createElement('div') this.lightDom.innerHTML = 'red' const buttonDom = document.createElement('button') buttonDom.innerHTML = '切换' buttonDom.onclick = function() &#123; self.currentLight.clickButton.call(self) &#125; document.body.appendChild(this.lightDom) document.body.appendChild(buttonDom) &#125;&#125;const light = new Light()light.init() 表驱动的有限状态机这种有限状态机核心是基于表驱动的。我们可以在表中很清楚地看到下一个状态是由当前状态和行为共同决定的。这样一来，我们就可以在表中查找状态，而不必定义很多条件分支。 当前状态→条件↓ 状态 A 状态 B 状态 C 条件 X … … … 条件 Y … 状态 C … 条件 Z … … … 我们可以借助 javascript-state-machine 来轻松的创建一个有限状态机，下面我们用这个库来实现之前的灯光程序。 123456789101112131415161718192021222324252627282930313233343536373839import StateMachine from 'javascript-state-machine'class Light &#123; constructor() &#123; this.fsm = new StateMachine(&#123; init: 'red', transitions: [ &#123; name: 'step', from: 'red', to: 'green' &#125;, &#123; name: 'step', from: 'green', to: 'yellow' &#125;, &#123; name: 'step', from: 'yellow', to: 'red' &#125; ], methods: &#123; // 观察状态更改生命周期 onStep(lifecycle, instance) &#123; // lifecycle: 一个包含状态更改信息的对象 instance: 执行 step 传进来的参数 instance.lightDom.innerHTML = lifecycle.to &#125; &#125; &#125;) this.lightDom = null &#125; init() &#123; const self = this this.lightDom = document.createElement('div') this.lightDom.innerHTML = this.fsm.state const buttonDom = document.createElement('button') buttonDom.innerHTML = '切换' buttonDom.onclick = function() &#123; self.fsm.step(self) &#125; document.body.appendChild(this.lightDom) document.body.appendChild(buttonDom) &#125;&#125;const light = new Light()light.init() 观察者（Observer）模式观察者模式又叫发布—订阅模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我们一般用事件模型来替代传统的发布—订阅模式。 举一个现实世界的例子：小明到4s店去买车，但被销售告知自己看中的型号暂时没货，到货时间不明，于是小明记下了销售的电话，每天都打一个电话去询问车子是否有货。如果有100像小明这样的客户，那么这个销售每天就会接到100个电话来询问车子的到货情况。实际上没有销售会这样做，他只需要记录下等待车子到货的客户名单，车子一到货遍历客户名单发短信通知一遍就可以了。 在刚刚的例子中，销售使用的就是观察者模式。像小明一样的客户是订阅者，他们订阅了车子的到货信息。而销售则是发布者，车子到货以后会给订阅者们发布到货信息。 观察者模式有两个特点： 可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。在异步编程中使用观察者模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 使用 addEventListener 方法在 DOM 上绑定事件函数就是观察者模式的一种应用。 12345document.body.addEventListener('click', function() &#123; console.log('click!')&#125;)document.body.click() // 模拟用户点击事件 我们利用 addEventListener 方法将指定的监听器注册到目标对象上，这里做的就是订阅者的工作，而用户点击该 DOM 元素时充当的就是发布者的角色。 观察者模式的实现我们用观察者模式来实现一个上面销售卖车的例子。 123456789101112131415161718192021222324252627282930const seller = &#123; clientList: [], listen(fn) &#123; this.clientList.push(fn) &#125;, trigger() &#123; for (let i = 0, fn; fn = this.clientList[i++];) &#123; fn.apply(this, arguments) &#125; &#125;&#125;// 小明订阅车辆到货事件seller.listen(function(price) &#123; console.log(`车已到货，价格$&#123;price&#125;元。`)&#125;)// 小红订阅车辆到货事件seller.listen(function(price) &#123; console.log(`车已到货，价格$&#123;price&#125;元。`)&#125;)// 销售发布车辆到货消息seller.trigger('10万')seller.trigger('15万')// 输出：// 车已到货，价格10万元。// 车已到货，价格10万元。// 车已到货，价格15万元。// 车已到货，价格15万元。 发布者对象 seller 里有一个 clientList 列表用来保存订阅者事件，订阅者通过调用发布者对象的 listen 方法传入订阅事件来订阅车子的到货情况。车子一旦到货，发布者对象会调用 trigger 方法来按照订阅者事件名单上记录的方法向订阅者发布车子到货事件。这样就实现了一个简单的观察者模式。 但是这里还存在着一个问题，我们看到订阅者收到的是发布者收到的所有消息，那如果小明和小红分别想买不同型号的车，他们也会收到其它型号车辆的订阅消息，这显然是一种浪费。所以我们有必要增加一个用作标识的 key ，来让订阅者只订阅自己感兴趣的内容。 123456789101112131415161718192021222324252627282930313233const seller = &#123; clientList: &#123;&#125;, listen(key, fn) &#123; if (!Array.isArray(this.clientList[key])) &#123; this.clientList[key] = [] &#125; this.clientList[key].push(fn) &#125;, trigger(key, ...args) &#123; if (Array.isArray(this.clientList[key]) &amp;&amp; this.clientList[key].length &gt; 0) &#123; for (let i = 0, fn; fn = this.clientList[key][i++];) &#123; fn.apply(this, args) &#125; &#125; &#125;&#125;// 小明订阅车型A的到货事件seller.listen('modelA', function(price) &#123; console.log(`车已到货，价格$&#123;price&#125;元。`)&#125;)// 小红订阅车型B的到货事件seller.listen('modelB', function(price) &#123; console.log(`车已到货，价格$&#123;price&#125;元。`)&#125;)// 销售分别发布两个型号车辆的到货消息seller.trigger('modelA', '10万')seller.trigger('modelB', '15万')// 输出：// 车已到货，价格10万元。// 车已到货，价格15万元。 观察者模式的通用实现我们来实现一个通用型的观察者对象，让任何销售（seller）都可以通过这个对象来给自己添加基本的订阅和发布功能，并且再新增一个取消订阅的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通用的观察者对象const eventObj = &#123; clientList: &#123;&#125;, listen(key, fn) &#123; if (!Array.isArray(this.clientList[key])) &#123; this.clientList[key] = [] &#125; this.clientList[key].push(fn) &#125;, trigger(key, ...args) &#123; if (Array.isArray(this.clientList[key]) &amp;&amp; this.clientList[key].length &gt; 0) &#123; for (let i = 0, fn; fn = this.clientList[key][i++];) &#123; fn.apply(this, args) &#125; &#125; &#125;, remove(key, fn) &#123; if ( Array.isArray(this.clientList[key]) &amp;&amp; this.clientList[key].length &gt; 0 &amp;&amp; fn ) &#123; this.clientList[key] = this.clientList[key].filter(_fn =&gt; fn !== _fn) &#125; &#125;&#125;// 给传进来的对象装载通用观察者对象的属性及方法const installEvent = function(obj) &#123; for (let key in eventObj) &#123; obj[key] = eventObj[key] &#125;&#125;const seller = &#123;&#125; // 创建一个发布者对象installEvent(seller)// 声明两个订阅事件function f1(price) &#123; console.log(`f1: 车已到货，价格$&#123;price&#125;元。`)&#125;function f2(price) &#123; console.log(`f2: 车已到货，价格$&#123;price&#125;元。`)&#125;seller.listen('modelA', f1)seller.listen('modelA', f2)seller.remove('modelA', f1) // 取消订阅seller.trigger('modelA', '10万')// 输出：// f1: 车已到货，价格10万元。 全局的观察者对象再观察一下上面的代码，我们发现还存在着至少两个缺点： 我们给每个发布者对象都添加了 clientList 缓存列表， listen 和 trigger 等方法，这其实是一种资源浪费。 小明和销售对象之间还是存在一定耦合性，小明至少要知道销售对象的名字是 seller ，才能顺利的订阅到事件。 这里可以创建一个全局的 observer 对象来解决。我们把所有的订阅都交给这个对象，同样发布工作也让这个对象来执行，它充当一个中介者的角色，把订阅者和发布者联系起来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Observer &#123; constructor() &#123; this.clientList = [] &#125; // 订阅 on(key, fn) &#123; if (!Array.isArray(this.clientList[key])) &#123; this.clientList[key] = [] &#125; this.clientList[key].push(fn) &#125; // 发布 emit(key, ...args) &#123; if (Array.isArray(this.clientList[key]) &amp;&amp; this.clientList[key].length &gt; 0) &#123; for (let i = 0, fn; fn = this.clientList[key][i++];) &#123; fn.apply(this, args) &#125; &#125; &#125; // 取消订阅 off(key, fn) &#123; if ( Array.isArray(this.clientList[key]) &amp;&amp; this.clientList[key].length &gt; 0 &amp;&amp; fn ) &#123; this.clientList[key] = this.clientList[key].filter(_fn =&gt; fn !== _fn) &#125; &#125;&#125;// 声明两个订阅事件function f1(price) &#123; console.log(`f1: 车已到货，价格$&#123;price&#125;元。`)&#125;function f2(price) &#123; console.log(`f2: 车已到货，价格$&#123;price&#125;元。`)&#125;const observer = new Observer()observer.on('modelA', f1)observer.on('modelA', f2)observer.off('modelA', f1)observer.emit('modelA', '10万')// 输出：// f2: 车已到货，价格10万元。 到这里我们已经基本上实现了观察者模式。除了正常的订阅者先订阅事件，发布者再发布的流程之外，也可以先发布再订阅（这通常放生在发布事件的时机比订阅事件早时）。 我们也可以建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 QQ 的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。 还可以增加例如 once 订阅方法让订阅者提供的事件只被发布一次，增加 create 方法创建单独的命名空间 (namespace) 来避免大量订阅事件命名冲突的问题。 观察者模式的优缺点观察者模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。 缺点即是创建订阅者本身要消耗一定的时间和内存，如果订阅一个消息后，此消息始终都未发生，这个订阅者会始终存在于内存中。另外，观察者模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。 中介者（Mediator）模式面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。 假设现在我们要开发一款对战游戏，游戏的首个版本功能比较简单，只支持两个玩家对战，并将对战的结果输出。 123456789101112131415161718192021222324252627282930313233class Player &#123; constructor(name) &#123; this.name = name this.enemy = null // 敌人 &#125; win() &#123; console.log(`$&#123;this.name&#125; won!`) &#125; lose() &#123; console.log(`$&#123;this.name&#125; lost!`) &#125; die() &#123; this.lose() this.enemy &amp;&amp; this.enemy.win() &#125;&#125;// 新建两个玩家const player1 = new Player('player1')const player2 = new Player('player2')// 为两个玩家相互设置敌人player1.enemy = player2player2.enemy = player1player2.die()// 输出：// player2 lost!// player1 won! 我们写一个 Player 类来创建玩家，每个玩家分别有 win 、lose 、die 三个方法来执行对战的过程。 现在我们改进一下游戏，使游戏支持更多的玩家参与，并将多个玩家分成红蓝两队。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const players = [] // 存放所有玩家的列表class Player &#123; constructor(name, teamColor) &#123; this.name = name this.state = 'alive' // 玩家状态 'alive' | 'dead' this.partners = [] // 队友列表 this.enemies = [] // 敌人列表 this.teamColor = teamColor &#125; win() &#123; console.log(`winner: $&#123;this.name&#125;`) &#125; lose() &#123; console.log(`loser: $&#123;this.name&#125;`) &#125; die() &#123; this.state = 'dead' // 遍历玩家列表，如果队友都死亡，宣告游戏结束，通知所有玩家结果 if (this.partners.every(partner =&gt; partner.state === 'dead')) &#123; console.log('游戏结束！') this.lose() // 通知自己游戏失败 this.partners.forEach(partner =&gt; &#123; partner.lose() &#125;) this.enemies.forEach(enemy =&gt; &#123; enemy.win() &#125;) &#125; &#125;&#125;// 创建玩家的工厂方法function playerFactory(name, teamColor) &#123; const newPlayer = new Player(name, teamColor) // 通知所有玩家，有新角色加入 players.forEach(player =&gt; &#123; if (player.teamColor === newPlayer.teamColor) &#123; // 如果是同一队的玩家，相互添加到队友列表 player.partners.push(newPlayer) newPlayer.partners.push(player) &#125; else &#123; // 相互添加到敌人列表 player.enemies.push(newPlayer) newPlayer.enemies.push(player) &#125; &#125;) players.push(newPlayer) return newPlayer&#125;// 创建红队成员const player1 = playerFactory('player1', 'red'), player2 = playerFactory('player2', 'red'), player3 = playerFactory('player3', 'red'), player4 = playerFactory('player4', 'red')// 创建蓝队成员const player5 = playerFactory('player5', 'blue'), player6 = playerFactory('player6', 'blue'), player7 = playerFactory('player7', 'blue'), player8 = playerFactory('player8', 'blue')// 让红队玩家全部死亡player1.die()player2.die()player3.die()player4.die()// 输出：// 游戏结束！// loser: player4// loser: player1// loser: player2// loser: player3// winner: player5// winner: player6// winner: player7// winner: player8 现在我们已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。当每个玩家的状态发生改变时，都要遍历所有玩家来通知到所有对象，一旦玩家数量、游戏队伍或者玩家状态增多时，代码将变得十分复杂，各个玩家队伍的耦合性将十分高，非常不利于维护。 使用中介者模式我们用中介者模式来改进一下上面的游戏。新增一个中介者对象 playerDirector ，然后改进 Player 对象，让它不再负责具体的执行逻辑，而是把操作转交给中介者对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class Player &#123; constructor(name, teamColor) &#123; this.name = name this.state = 'alive' // 玩家状态 'alive' | 'dead' this.teamColor = teamColor &#125; win() &#123; console.log(`winner: $&#123;this.name&#125;`) &#125; lose() &#123; console.log(`loser: $&#123;this.name&#125;`) &#125; die() &#123; this.state = 'dead' playerDirector.receiveMessage('playerDead', this) // 给中介者对象发送消息，玩家死亡 &#125; // 移除玩家 remove() &#123; playerDirector.receiveMessage('removePlayer', this) // 给中介者对象发送消息，移除一个玩家 &#125;&#125;// 创建玩家的工厂方法function playerFactory(name, teamColor) &#123; const newPlayer = new Player(name, teamColor) playerDirector.receiveMessage('addPlayer', newPlayer) // 给中介者对象发送消息，新增玩家 return newPlayer&#125;// 中介者对象const playerDirector = (function() &#123; const players = &#123;&#125; // 分队伍存放所有玩家 const operations = &#123;&#125; // 中介者对象可以执行的所有操作 // 新增一个玩家 operations.addPlayer = function(player) &#123; const teamColor = player.teamColor players[teamColor] = players[teamColor] || [] // 如果该颜色的队伍还没有成立，则新成立一个队伍 players[teamColor].push(player) &#125; // 移除一个玩家 operations.removePlayer = function(player) &#123; const teamPlayers = players[player.teamColor] // 该队伍的所有队员 // 遍历删除 teamPlayers.some((item, index) =&gt; &#123; if (teamPlayers[index] === player) &#123; teamPlayers.splice(index, 1) return true &#125; return false &#125;) &#125; // 玩家死亡 operations.playerDead = function(player) &#123; const teamPlayers = players[player.teamColor] // 该队伍的所有队员 // 遍历队伍列表，如果队友都死亡，宣告游戏结束，通知所有玩家结果 if (teamPlayers.every(partner =&gt; partner.state === 'dead')) &#123; console.log('游戏结束！') for (let color in players) &#123; players[color].forEach(item =&gt; &#123; color === player.teamColor ? item.lose() : item.win() &#125;) &#125; &#125; &#125; // 接收消息方法 const receiveMessage = function() &#123; const message = Array.prototype.shift.call(arguments) operations[message].apply(this, arguments) &#125; return &#123; receiveMessage &#125;&#125;)()// 创建红队成员const player1 = playerFactory('player1', 'red'), player2 = playerFactory('player2', 'red'), player3 = playerFactory('player3', 'red'), player4 = playerFactory('player4', 'red')// 创建蓝队成员const player5 = playerFactory('player5', 'blue'), player6 = playerFactory('player6', 'blue'), player7 = playerFactory('player7', 'blue'), player8 = playerFactory('player8', 'blue')// 移除一个玩家player2.remove()// 让红队玩家全部死亡player1.die()player3.die()player4.die()// 输出：// 游戏结束！// loser: player1// loser: player3// loser: player4// winner: player5// winner: player6// winner: player7// winner: player8 可以看到，除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。我们还可以继续给中介者扩展更多功能（例如上面示例中移除玩家的 removePlayer 功能），以适应游戏需求的不断变化。 中介者模式的优缺点 优点 使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。 缺点 系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。 中介者模式的总结中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象（类似不和陌生人说话）。 中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟我们写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那我们就可以考虑用中介者模式来重构代码。 迭代器（Iterator）模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 现在流行的大部分语言都有了内置的迭代器实现， JavaScript 也提供了 Array.prototype.forEach 方法实现迭代器。 实现自己的迭代器12345678910111213const each = function(arr, callback) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; callback.call(arr[i], arr[i], i, arr) &#125;&#125;each(['a', 'b'], (item, i) =&gt; &#123; console.log(item, i)&#125;)// 输出：// a 0// b 1 内部迭代器和外部迭代器先来看一下内部迭代器和外部迭代器的特点： 内部迭代器完全接手整个迭代过程，外部只需要一次初始调用。内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。 外部迭代器必须显式地请求迭代下一个元素（next()）。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。 我们上面代码实现的代码就是一个内部迭代器，外部只需要调用一次 each 函数即可完成整个迭代。这样虽然很方便，但是如果我们想要在迭代的过程中处理一些事情就很难办到。 下面来看一下外部迭代器的实现： 12345678910111213141516171819202122232425262728293031323334353637383940const OuterIterator = function (obj) &#123; let current = 0 const next = function () &#123; current += 1 &#125; const isDone = function() &#123; return current &gt;= obj.length &#125; const getCurrentItem = function() &#123; return obj[current] &#125; return &#123; next, isDone, getCurrentItem &#125;&#125;const outerIterator = OuterIterator(['a', 'b'])function test() &#123; while(!outerIterator.isDone()) &#123; console.log(outerIterator.getCurrentItem()) // do something… outerIterator.next() &#125; console.log('done!')&#125;test()// 输出：// a// b// done! 可以看到，外部迭代器的每一次迭代都是需要我们自己手动调用 next() 方法来实现，就像 Generator 函数，这样就把迭代的控制权交给了我们自己，使迭代器更加灵活。 外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定。 访问者（Visitor）模式访问者模式是一种将算法与对象结构分离的软件设计模式。 这个模式的基本想法如下：首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象；访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中回调访问者的 visit 方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。《访问者模式》来自维基百科 概括来说，就是针对固定的对象结构，给不同的访问者提供不同的操作。 比如我们有一台电脑 Computer ，它是由鼠标 Mouse 、键盘 Keyboard 等不同的硬件组成的，针对不同的硬件我们需要做不同的操作，这里就可以使用访问者对象来处理。 123456789101112131415161718192021222324252627282930313233343536373839class Mouse &#123; accept(computerVisitor) &#123; computerVisitor.visit(this) &#125;&#125;class Keyboard &#123; accept(computerVisitor) &#123; computerVisitor.visit(this) &#125;&#125;class Computer &#123; constructor() &#123; this.parts = [new Mouse(), new Keyboard()] &#125; accept(computerVisitor) &#123; for (let i = 0; i &lt; this.parts.length; i++) &#123; this.parts[i].accept(computerVisitor) // 访问电脑的各个设备 &#125; computerVisitor.visit(this) // 访问电脑本身 &#125;&#125;// 访问者类class ComputerVisitor &#123; visit(device) &#123; console.log('访问: ', device.constructor.name) &#125;&#125;const computer = new Computer()computer.accept(new ComputerVisitor())// 输出：// 访问: Mouse// 访问: Keyboard// 访问: Computer 我们来分析一下上面的代码。这里我们创建了一个 Computer 类，它内部包含 Mouse 、Keyboard 类，它们都提供了一个 accept 方法用来接收访问者对象。后面我们又创建了 ComputerVisitor 类来作为访问者对象，这个对象里面提供了一个 visit 方法，这个方法接收一个元素对象 device ，在这里指代的是电脑的各个部件，我们可以针对不同的元素对象作出不同的处理（上面的代码里我们省略了这部分，只是简单的打印出了各个部件的名字）。 备忘录（Memento）模式备忘录模式是一种软件设计模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 重点在于“不破坏封装性”这几个字上，程序的可维护性永远是设计模式关注的重点，上层框架使用状态时，都不需要知道具体对象状态的细节，而实现这一点的就是 Memento 这个抽象的备忘录类（类似 Redux 的设计原则）。 主要应用就是提供“后悔药”的功能，比如编辑器里的撤销功能，打游戏的存档功能等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 备忘录类（包含了要被恢复的对象的状态）class Memento &#123; constructor(content) &#123; this.content = content &#125; getContent() &#123; return this.content &#125;&#125;// 备忘录管理类（负责从 Memento 中恢复对象的状态）class Caretaker &#123; constructor() &#123; this.list = [] &#125; add(memento) &#123; this.list.push(memento) &#125; get(index) &#123; return this.list[index] &#125;&#125;// 创建并在 Memento 对象中存储状态class Originator &#123; constructor() &#123; // 这里省略了将 content 设置为“只读”的过程，实际上 content 应该是“只读”的，要修改它只能调用 setContent 方法 this.content = null &#125; setContent(content) &#123; this.content = content &#125; getContent() &#123; return this.content &#125; saveContentToMemento() &#123; return new Memento(this.content) &#125; getContentFromMemento(memento) &#123; this.content = memento.getContent() &#125;&#125;const originator = new Originator()const caretaker = new Caretaker()originator.setContent('#1')caretaker.add(originator.saveContentToMemento()) // 将内容保存至 Caretakeroriginator.setContent('#2')caretaker.add(originator.saveContentToMemento()) // 将内容保存至 Caretakeroriginator.setContent('#3')console.log(originator.getContent()) // #3（取到当前内容）originator.getContentFromMemento(caretaker.get(0)) // 恢复到首次保存的内容console.log(originator.getContent()) // #1（取到当前内容为首次保存的内容） 备忘录模式的缺点就是消耗资源。因为存储的是完整状态而非 Diff ，所以如果类的成员过多，会占用大量的内存。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端包管理工具]]></title>
    <url>%2F2022%2Fjs-package.html</url>
    <content type="text"><![CDATA[包的英语单词：Package，针对编程来说，更具象的名字叫「软件包」。代表了一组特定功能的源码集合。软件包可以是一个单独的源码文件，也可以是一个包含很多文件和目录的文件夹。具体如何呈现，就要看这个软件包提供了什么样的功能。 软件包就是有人对一些具有重复性的功能问题做出了针对性的解决方案。我们在软件开发的过程中有了相应的功能需求时，除了自己写，也可以选择直接使用这些有功能针对性的软件包。这除了可以节省自己大量的精力和时间，也能让自己少踩一些坑。 在软件开发过程中使用包不是必须的，但却是一项最佳的工程化实践。 npmnpm是什么？ npm （node package manager）为你和你的团队打开了连接整个 JavaScript 天才世界的一扇大门。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package）（即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。 npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具（CLI） 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。 注册表 是一个巨大的数据库，保存了每个包（package）的信息。 CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 npm安装包有两种方式用来安装 npm 包：本地安装和全局安装。至于选择哪种方式来安装，取决于我们如何使用这个包。 如果你自己的模块依赖于某个包，并通过 Node.js 的 require 加载，那么你应该选择本地安装，这种方式也是 npm install 命令的默认行为。 如果你想将包作为一个命令行工具，（比如 grunt CLI），那么你应该选择全局安装。 可以使用以下命令安装一个包： 1$ npm install &lt;package_name&gt; 上述命令执行之后将会在当前的目录下创建一个 node_modules 的目录（如果不存在的话），然后将下载的包保存到这个目录下。 如果需要将包安装到全局，你应该使用以下命令： 1$ npm install -g &lt;package_name&gt; package.json项目的 package.json 文件是配置和描述如何与程序交互和运行的中心。npm CLI用它来识别你的项目并了解如何处理项目的依赖关系。package.json 文件使 npm 可以启动你的项目、运行脚本、安装依赖项、发布到 NPM 注册表以及许多其他有用的任务。 你的项目还必须包含 package.json ，然后才能从 NPM 安装软件包。 package.json 位于项目的根目录下。 包的版本号规则npm 包的版本号遵循以下规则： 12主版本号.次版本号.修补版本号major.minor.patch major：新的架构调整，不兼容老版本 minor：新增功能，兼容老版本 patch：修复bug，兼容老版本 version 仅接受指定的版本 ~version 大概匹配兼容某个版本 如果minor版本号指定了，那么minor版本号不变，而patch版本号任意 如果minor和patch版本号未指定，那么minor和patch版本号任意 如：~1.1.2，表示&gt;=1.1.2 &lt;1.2.0，可以是1.1.2，1.1.3，1.1.4，…，1.1.n 如：~1.1，表示&gt;=1.1.0 &lt;1.2.0，可以是同上 如：~1，表示&gt;=1.0.0 &lt;2.0.0，可以是1.0.0，1.0.1，1.0.2，…，1.0.n，1.1.n，1.2.n，…，1.n.n ^version 兼容某个版本 版本号中最左边的非0数字的右侧可以任意 如果缺少某个版本号，则这个版本号的位置可以任意 如：^1.1.2 ，表示&gt;=1.1.2 &lt;2.0.0，可以是1.1.2，1.1.3，…，1.1.n，1.2.n，…，1.n.n 如：^0.2.3 ，表示&gt;=0.2.3 &lt;0.3.0，可以是0.2.3，0.2.4，…，0.2.n 如：^0.0，表示 &gt;=0.0.0 &lt;0.1.0，可以是0.0.0，0.0.1，…，0.0.n l**atest** 安装的永远是最新发布的版本 &gt;version 必须大于某个版本 &gt;=version 可大于或等于某个版本 &lt;version 必须小于某个版本 &lt;=version 可以小于或等于某个版本 x x的位置表示任意版本 如：1.2.x，表示可以1.2.0，1.2.1，…，1.2.n * 任意版本，””也表示任意版本 version1 - version2 大于等于version1，小于等于version2 range1 || range2 满足range1或者满足range2，可以多个范围 如：&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 ，表示满足这三个范围都可以 12345678910111213141516&#123; "dependencies": &#123; "foo": "1.0.0 - 2.9999.9999", "bar": "&gt;=1.0.2 &lt;2.1.2", "baz": "&gt;1.0.2 &lt;=2.3.4", "boo": "2.0.1", "qux": "&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0", "asd": "http://asdf.com/asdf.tar.gz", "til": "~1.2", "elf": "~1.2.3", "two": "2.x", "thr": "3.3.x", "lat": "latest", "dyl": "file:../dyl" // 本地路径 &#125;&#125; package-lock.json当我们执行 npm install 命令时，会自动在项目的根目录创建一个 package-lock.json 文件，该文件可以理解成对结合了逻辑树（package.json里面定义的依赖关系树）和物理树（node_modules文件夹下的结构）的一个快照，里面有明确的各依赖版本号，实际安装的结构，也有逻辑树的结构。 该文件用于描述依赖树的详细情况，以保证可以重复安装完全相同的依赖项。并允许npm跳过先前安装包的重复元数据解析来优化安装过程。 我们无法直接还原项目某一时刻的所有依赖项（node_modules），但通过 package.json 和 package-lock.json 文件，可以推导出项目某一时刻的所有依赖项并完全还原。 要完全按照 package-lock.json 文件里的定义安装依赖项，可以使用 [npm ci](https://docs.npmjs.com/cli/v9/commands/npm-ci) 命令。 yarnyarn 与 npm 类似，都是包管理工具。yarn 中宣传的点是： 快速：yarn会缓存下载过的每一个包，这样就不用再次下载了。同时会并行执行安装任务，以达到更快的速度。 安全：yarn会校验每个已安装包的完整性，再执行它的代码。 可靠：lock锁机制，保证在一个系统上运行的安装在其它任何系统上都能以完全相同的方式运行。 yarn.lockyarn 也有与 npm 类似的lock锁机制，这些信息存放在 yarn.lock 文件下。该文件会把项目下所有依赖项以及依赖项的依赖扁平化的展示出来，对于同包不同版本且规则相容的字段会放在同一级结构中。 像 npm ci 命令一样使用 yarn ： 1$ yarn install --frozen-lockfile nvmnvm (Node Version Manager)，即 node 版本管理工具，可以在同一台设备上安装和切换多个 node 版本，解决 node 各种版本存在不兼容的现象。 nvm常用命令12345678910111213141516171819# 安装指定 node 版本$ nvm install &lt;version&gt;# 查看本地 node 版本$ nvm ls# 或$ nvm list# 查看远程 node 版本$ nvm ls-remote# 使用指定 node 版本$ nvm use &lt;version&gt;# 设置默认 node 版本$ nvm alias default &lt;version&gt;# 卸载指定 node 版本$ nvm uninstall &lt;version&gt; npxnpm 从5.2版本开始，增加了 npx 命令，所以可以直接使用 npx 命令。如果不能使用，可以手动安装一下。 1$ npm install -g npx 调用项目安装的模块npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内安装了测试工具 Mocha ，一般来说，想要调用它只能在项目脚本和 package.json 的 script 字段里面，如果想在命令行下调用，必须像下面这样。 12# 项目的根目录下执行$ node-modules/.bin/mocha --version npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。 1$ npx mocha --version npx 的原理很简单，就是运行的时候，会到 node_modules/.bin 路径和环境变量 $PATH 里面，检查命令是否存在。 避免全局安装模块除了调用项目内部的模块，npx 还能避免全局安装的模块（可以指定版本号）。比如 create-react-app 这个模块就是全局安装，npx 可以运行它，而且不进行全局安装。 1$ npx create-react-app my-react-app 上面代码运行时，npx 将 create-react-app 下载到一个临时目录（只要 npx 后面的模块无法在本地发现，就会下载同名模块），使用以后再删除，以后再使用该命令时重新下载。 --no-install 参数和--ignore-existing 参数如果想让 npx 强制使用本地模块，不下载远程模块，可以使用 —no-install 参数，如果本地不存在该模块，就会报错。 1$ npx --no-install http-server 反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用 --ignore-existing 参数。比如，本地已经全局安装了 create-react-app ，但还是想使用远程模块，就用这个参数。 1$ npx --ignore-existing create-react-app my-react-app 使用不同版本的 node利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 node模块。 1$ npx node@0.12.8 -v 上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。 某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。 指定参数-p 参数参数用于指定 npx 所要安装的模块，可以在需要安装多个模块的场景时使用。 1$ npx -p lolcatjs -p cowsay [command] npx部分转载自 npx 使用教程 - 阮一峰的网络日志。 pnpm当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖（dependency），就会有 100 份该依赖的副本保存在硬盘上。 而在使用 pnpm 时，依赖会被存储在内容可寻址的存储中，所以： 如果你用到了某依赖项的不同版本，只会将不同版本间有差异的文件添加到仓库。 例如，如果某个包有100个文件，而它的新版本只改变了其中1个文件。那么 pnpm update 时只会向存储中心额外添加1个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。 所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。 因此，您在磁盘上节省了大量空间，这与项目和依赖项的数量成正比，并且安装速度要快得多！ 创建非扁平化的 node_modules 文件夹 Lockfile您应该始终提交 Lockfile（ pnpm 生成的 pnpm-lock.yaml 文件）。 这是出于多种原因，主要是： 在 CI 和生产环境中能够更快地完成安装，因为解析依赖的过程可以被跳过。 开发，测试和生产环境之间强制执行一致的安装和解析方案，这意味着测试和生产中使用的包将与您开发项目时完全相同。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数里的this到底指向谁？]]></title>
    <url>%2F2020%2Fjs-this.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于箭头函数里的this这个问题一直很模糊，之前看了很多教程虽然知道了其行为，但是具体实现规则一直不太清晰。今天为了彻底搞懂这个问题，查了很多资料，感觉查到的很多例子不是很能清晰的描述这种行为。所以今天特地自己写一遍文章来说明一下。 普通函数里的this&emsp;&emsp;先来说一下普通函数里的this。 12345var a = 1function test() &#123; console.log(this.a) // this指向window，打印1&#125;test() &emsp;&emsp;在普通函数里，this的值在定义时是不明确的，要等到调用时才能确定，谁调用就指向谁。上面代码里的test()是在全局作用域调用的，所以自然就指向window，控制台会打印1。 &emsp;&emsp;再来看一个例子： 12345678var a = 1var obj = &#123; a: 2, test: function() &#123; console.log(this.a) &#125;&#125;obj.test() // 2 &emsp;&emsp;上面的代码我们把test函数定义在里对象obj里，调用的时候是用obj来调用的，所以test函数里的this自然就指向obj，最后函数会打印2。 &emsp;&emsp;再来看一个： 123456789var a = 1var obj = &#123; a: 2, test: function () &#123; console.log(this.a) &#125;&#125;var w = obj.testw() // 1 &emsp;&emsp;上面的代码我们把obj.test函数里的代码赋值给了一个全局变量w，然后用全局变量w调用了test函数，所以这里的this指向的也是window。 &emsp;&emsp;还有一种情况： 123456789101112var a = 1var obj = &#123; a: 2, test: function () &#123; function fn() &#123; console.log(this.a) &#125; return fn() &#125;&#125;obj.test() // 1 &emsp;&emsp;这里来看obj.test方法，这个方法里我们创建了一个fn函数，最后将fn函数的结果作为obj.test的结果返回，这里的fn是用return方法返回的，并没有被其它对象直接调用，普通函数里this也并不会被继承，所以这里的this指向全局的window。 &emsp;&emsp;setTimeout方法和setInterval方法中的this均指向window，如下： 1234567891011var a = 1var obj = &#123; a: 2, test: function () &#123; setTimeout(function () &#123; console.log(this.a) &#125;, 1000) &#125;&#125;obj.test() // 1 &emsp;&emsp;上面的几种情况就是普通函数里this的指向。 &emsp;&emsp;使用call()、apply()、bind()等方法可以手动改变普通函数里this的指向，在本文里就不详细叙述了。 箭头函数里的this先说结论： 箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this（结论出自MDN - 箭头函数） 使用call()、apply()、bind()等方法并不会直接修改箭头函数内的this 箭头函数的this是在创建时就已经确定了 123456789var a = 1var obj = &#123; a: 2, test: () =&gt; &#123; console.log(this.a) &#125;&#125;obj.test() // 1 &emsp;&emsp;这里的this是在箭头函数里的，所以会从自己的作用域链的上一层，也就是obj对象来继承this。最后一行obj是在全局中调用的，所以obj的this指向window，其结果打印的是1。 1234567891011function a() &#123; function b() &#123; console.log(this === window) // true var c = () =&gt; &#123; console.log(this) // window &#125; return c() &#125; return b()&#125;a() &emsp;&emsp;上面的这个例子，c是箭头函数，所以c里的this继承自己的作用域链的上一层b，b是直接return返回的结果，this指向window。 &emsp;&emsp;我们再把上面的例子修改一下： 123456789101112131415var obj = &#123; a: 'xxx'&#125;function a() &#123; function b() &#123; console.log(this === obj) // true var c = () =&gt; &#123; console.log(this) // obj对象 &#125; return c() &#125; b.call(obj)&#125;a() &emsp;&emsp;上面的例子我们手动用call()方法把b的this指向更改为了obj，通过打印出来的结果再一次印证了箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this这一结论。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将一个JavaScript数组打乱]]></title>
    <url>%2F2020%2Fjs-array-order.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;如何将一个js数组的顺序打乱并且又能做到完全随机打乱呢？今天在网上看到了这样一个算法，觉得思路很不错，写上来记录一下。 &emsp;&emsp;比如我们有这样一个数组： 1let arr = [1, 2, 3, 4, 5, 6] &emsp;&emsp;实现思路是这样的： 首先用数组的最后一个值arr[arr.length - 1]来与前面的5个值中随机抽取一个值交换位置。 在上一步中我们已经把数组末尾的值调换了位置，接着按照同样的方法对倒数第二个值进行同样的操作，再调换一次位置。 对下一个值执行相同的操作，直到全部执行完毕（执行到数组的第二个值就可以了）。 &emsp;&emsp;下面我们用代码来实现一下： 1234567891011121314151617let arr = [1, 2, 3, 4, 5, 6]function randomSortArr(arr) &#123; // 生成0到max之间的随机数 function exchange(max) &#123; return Math.floor(Math.random() * (max + 1)) &#125; for (let i = arr.length - 1; i &gt; 0; i--) &#123; let randomIndex = exchange(i - 1) let num = arr[i] arr[i] = arr[randomIndex] arr[randomIndex] = num &#125; return arr&#125;console.log(randomSortArr(arr)) // [2, 6, 5, 1, 4, 3] &emsp;&emsp;结果如我们所愿，数组被成功打乱了。下面再上一个优化了代码数量后的版本（方法一样，只是简化了代码量，第一个方法便于读者理解）： 1234567891011let arr = [1, 2, 3, 4, 5, 6]function randomSortArr(arr) &#123; for (let i = arr.length - 1; i &gt; 0; i--) &#123; let randomIndex = Math.floor(Math.random() * i); [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]] &#125; return arr&#125;console.log(randomSortArr(arr)) 算法转载自知乎]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js中的events模块]]></title>
    <url>%2F2020%2Fnode-events.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在Node.js（以下简称node）中，有一个events模块，中文名称是“事件触发器”。node的一大特点就是事件驱动。在node里，很多行为都会触发相应的事件，而所有能触发事件的对象都是events模块类的实例，它们都有添加事件的能力。 on()&emsp;&emsp;先看代码： 123456789101112131415const events = require('events')class MyEvent extends events &#123; &#125;const myevent = new MyEvent()// 注册监听器myevent.on('event1', function (a) &#123; console.log('event' + a)&#125;)// 使用ES6箭头函数注册监听器myevent.on('event2', (a) =&gt; &#123; console.log('event' + a)&#125;)// emit()触发事件myevent.emit('event1', 1)myevent.emit('event2', 2) &emsp;&emsp;上面的代码使用了一个MyEvent类继承了events类，使MyEvent类的实例有了注册事件监听器的能力。然后调用了on()函数，注册了两个监听器。on()函数可以接收两个参数，第一个参数是事件名称，第二个参数是一个函数，为触发事件时执行的方法，函数的参数为触发事件时要传给监听器的参数，可以没有或有若干个。我注册了两个监听器，其中第二个监听器的第二个函数参数是采用ES6的箭头的写法。两者的区别是箭头函数没有this，而普通函数的this关键字指向监听器所绑定类的实例，在上面的代码里也就是myevent。 &emsp;&emsp;添加好监听器后，用emit()触发事件，后面的参数就是添加监听器时，函数内传递的参数。 &emsp;&emsp;在node环境下运行上面的代码，就会输出： 12event1event2 &emsp;&emsp;上面的方法其实继承的是events模块的EventEmitter类，所以我们直接用如下方法也可以。 1234567const EventEmitter = require('events').EventEmitterconst myevent = new EventEmitter()myevent.on('event', () =&gt; &#123; console.log('event') // event&#125;)myevent.emit('event') once()&emsp;&emsp;除了用on()函数添加监听器，还可以用once()添加仅可以被触发一次的事件。 1234567891011const events = require('events')class MyEvent extends events &#123; &#125;const myevent = new MyEvent()myevent.once('event', () =&gt; &#123; console.log('event')&#125;)myevent.emit('event')// 用once()添加的触发器只会被触发一次，下面的语句不会被执行。myevent.emit('event') setMaxListeners(n)&emsp;&emsp;默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 这有助于发现内存泄露。使用setMaxlisteners()方法，可以调整这个限制。参数为一个数字，即次数，参数为0表示不限次数。 12345678910111213const events = require('events')class MyEvent extends events &#123; &#125;const myevent = new MyEvent()myevent.setMaxListeners(11) // 修改事件监听器的数量为11// 给event事件添加11个监听器for (let i = 0; i &lt;= 10; i++) &#123; myevent.on('event', () =&gt; &#123; console.log(`event$&#123;i + 1&#125;`) &#125;)&#125;myevent.emit('event') &emsp;&emsp;上面的代码使用setMaxListeners()方法设置了myevent可以添加11个监听器（超过控制台会打印警告）。 removeListener()&emsp;&emsp;如果需要删除某个事件监听器的回调的话，可以使用removeListener()方法来操作。该方法接收两个参数，第一个参数为事件名称，第二个参数为事件的回调名称。（这里说的回调其实就是当前监听事件的执行函数） 1234567891011121314151617181920const events = require('events')class MyEvent extends events &#123; &#125;const myevent = new MyEvent()function callback1() &#123; console.log('callback1')&#125;function callback2() &#123; console.log('callback2')&#125;myevent.on('event', callback1)myevent.on('event', callback2)// 删除callback1回调myevent.removeListener('event', callback1)// 触发事件myevent.emit('event') &emsp;&emsp;执行上面的代码后，只有callback2被触发执行了。 removeAllListeners()&emsp;&emsp;如果我们要删除所有的监听事件，或者删除某个监听事件下所有的执行函数，可以用removeAllListeners()方法。这个方法接收一个可选参数，为事件名称。传入事件名称将删除该事件名称下的所有执行函数。不传入参数将删除所有的监听事件。 12345678910111213141516171819202122const events = require('events')class MyEvent extends events &#123; &#125;const myevent = new MyEvent()function callback1() &#123; console.log('callback1')&#125;function callback2() &#123; console.log('callback2')&#125;// 这里添加了两个监听器myevent.on('event1', callback1)myevent.on('event2', callback2)myevent.removeAllListeners('event1') // 删除event1监听事件// myevent.removeAllListeners() // 如果执行这一句，event1和event2都将被删除// 触发事件myevent.emit('event1')myevent.emit('event2')]]></content>
      <categories>
        <category>技术</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Electron介绍（理论篇）]]></title>
    <url>%2F2019%2Felectron-desc.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Electron是一个能让你使用前端技术（JavaScript, HTML, CSS和Node.js）构建跨平台的桌面应用的框架。最初被GitHub开发，2013年4月11日以Atom Shell为名起步，2014年5月16日开源，2015年4月17日改名为Electron。 基于Electron实现的产品&emsp;&emsp;VsCode, Atom等。 Electron组成&emsp;&emsp;Electron主要由Node.js、Chromium和封装好的系统API三大部分组成。 &emsp;&emsp;在Electron构建的程序里，Chromium负责页面渲染进程，Node.js负责程序的逻辑部分，开发中可以使用所有Node.js的原生API，也可以使用npm平台上的所有模块。使用Electron的API可以实现如通知、自定义Windows任务栏/MacOS Dock、最近文档等操作系统原生功能。 Electron进程&emsp;&emsp;Electron有两种进程，分别是主进程和渲染进程。 &emsp;&emsp;主进程只能有一个，负责调用Electron的API实现系统功能，控制应用的生命周期，创建单独的渲染进程来加载web页面等。 &emsp;&emsp;每个单独的web页面都运行在属于它自己的渲染进程中，是相互独立的。这意味着某一个渲染进程崩溃了，并不会影响到其它的渲染进程。渲染进程负责渲染页面和处理相应的页面交互。有一点需要注意的是，渲染进程并不能直接调用与 GUI 相关的原生 API （比如操作系统菜单、创建新窗口等），因为渲染进程等于是使用的Chromium来展示web页面，在web页面中，直接操作原生的 GUI 资源是非常危险的，而且容易造成资源泄露。如果想要在渲染进程内使用GUI操作，可以与主进程产生通讯，请求主进程调用相应的API来操作。 Electron优缺点优点： 快速构建跨平台（Windows、MacOs、Linux）的桌面级应用 因为使用Node.js开发，所以npm平台下的包都可以使用，提升开发效率，避免重复造轮子 有很多现成的UI框架可以使用 缺点： 安装包体积略大（打包了Chromium） 性能不如原生应用]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parallels配置虚拟机网络（宿主机ip不固定，虚拟机ip固定）]]></title>
    <url>%2F2019%2Fparallels-network.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近我在Parallels里安装了一台ubuntu的虚拟机，因为平常都是用宿主机ssh远程到虚拟机上使用的，所以在配置虚拟机网络这一块就首先选择了桥接模式。Parallels里的桥接模式下，虚拟机可以和宿主机通信，可以和与宿主机同一局域网内且同一网段的其它设备通信，多个虚拟机之间也可以相互通信，也可以连接互联网，等于为虚拟机新分配了一个局域网地址，一般正常使用的话，我都是采用这种模式。但是这种模式下有一个问题，因为我用的是笔记本电脑，经常是在家和公司之间或者其它地方使用。这样当我的笔记本（宿主机）网络环境变了以后，我的虚拟机ip地址也会改变。虽然可以在虚拟机内设置固定ip，但宿主机的网段一旦改变，之前虚拟机设置的固定ip如果和宿主机不处于同一网段下的话，还是无法实现通信。举个栗子： 比如在公司的时候，宿主机被分配到的ip地址是 192.168.xxx.3这时如果采用桥接模式，虚拟机被分配到的ip地址是 192.168.xxx.4 ，这时是没问题的。可是如果回了家，宿主机的被分配到的ip地址是 192.168.yyy.3 &emsp;&emsp;这种时候要么虚拟机不固定ip，网段也变为了yyy，我每次开机都需要先查看虚拟机的ip地址，然后才能远程连接，这样太麻烦了。固定ip的话，因为宿主机的网段会变，而且不固定，又无法实现通信。所以这种模式显然不适合宿主机ip不固定的情况。 &emsp;&emsp;我先来整理一下我的需求： 宿主机和虚拟机之间可以正常通信。 多个虚拟机之间可以正常通信。 宿主机同一局域网下且网段相同的设备可以和虚拟机之间实现通信。 虚拟机可以正常连接互联网。 &emsp;&emsp;经过一番谷歌大法后，终于找到了解决方案。 &emsp;&emsp;首先在Parallels的“偏好设置”–“网络”中，勾选在系统偏好设置中显示和启用IPv4 DHCP，设置好起始地址和结束地址，这里可以重新设置一个网段（当然也可以点击做左边网卡列表的+号新加一块网卡来设置）。勾选了在系统偏好设置中显示这个选项以后，在你的mac中的“系统偏好设置”–“网络”里就可以看到这块网卡，里面有本机的ip地址。 &emsp;&emsp;然后添加端口转发。 &emsp;&emsp;最后把虚拟机的网络配置为共享网络。 &emsp;&emsp;这里解释一下我们都干了什么。首先我们添加了一个全新的192.168.8.xxx的网段，并把虚拟机的网络配置为了共享网络模式。这种模式等于宿主机新加了一块虚拟网卡给虚拟机使用。宿主机的网卡可以实现和同局域网下且同一网段的其它设备通信，同时宿主机的虚拟网卡也可以实现宿主机与虚拟机之间通信。我们还添加了端口转发，这一项设置是为了让和宿主机处于同一局域网下且同一网段的其它设备与虚拟机产生通信。直接通信是不行的，因为这些设备与虚拟机不处于同一网段（虚拟机处于新添加的192.168.8.xxx网段下），所以刚才设置的端口转发就派上了用场。上图设置了访问宿主机的ip+65532端口号，自动转发给我的名为“Ubuntu 18.04”的虚拟机的22端口，这样就可以通过ssh来直接远程我的Linux虚拟机。 &emsp;&emsp;最后再把虚拟机的ip固定一下，这样每次ssh连接虚拟机的时候就可以使用同一个ip地址了。 &emsp;&emsp;刚才我们转发到的是虚拟机的22端口，当然如果想让虚拟机充当web服务器的角色的话，也可以再添加一个80端口，就可以实现局域网内的web访问了。（宿主机可以直接访问虚拟机的ip地址，和宿主机处于同一局域网且同一网段的其它设备无法直接访问，需要访问宿主机的ip地址+转发前的端口号）]]></content>
      <categories>
        <category>技术</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Parallels</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript里的Promise]]></title>
    <url>%2F2019%2Fjs-promise.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;JavaScript在ES6版本中新增了Promise对象。 概述 Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 以上引用自MDN中对Promise的介绍。 &emsp;&emsp;Promise其实就是一个对异步操作结果的封装。一个Promise有三种状态： Pending: 初始状态，既不是成功，也不是失败状态。 Fulfilled: 表示操作成功完成。 rejected: 表示操作失败。 &emsp;&emsp;Promise翻译为保证，承诺的意思。这意味着一个Promise一旦有了结果，就不会再发生改变。Pending是初始状态，此时表明还没有获取到结果。一旦状态从Pending改变为Fulfilled或rejected后，状态便不会再发生改变。 &emsp;&emsp;在之前的ES5时代，我们通常会用回调函数来处理异步操作的结果。 123456789101112131415function successCallback() &#123; console.log('success!')&#125;function failCallback() &#123; console.log('fail!')&#125;function test() &#123; if (true) &#123; // 异步请求的结果 successCallback() &#125; else &#123; failCallback() &#125;&#125;test() &emsp;&emsp;上面的代码先是封装了两个回调函数，分别是成功和失败。然后在test函数内执行异步请求（忽略），根据异步请求的结果来执行对应的回调函数。如果在只有一层异步请求的时候，代码结构还算清晰。但实际业务中，往往会嵌套多层异步请求，层数一多，还用这种写法层层嵌套的话，代码会变得难以阅读和维护，也就是经典的回调地狱模式。所以这种情况就可以使用ES6新增的Promise方法。 &emsp;&emsp;Promise对象使用new操作符创建，接收一个函数作为参数，该函数又接收resolve和reject两个函数，这两个函数是ES6帮我们封装好的，我们直接调用就可以了。resolve表示成功时执行的函数，而reject表示失败时执行的函数。两个函数都可以传参，后期在.then里接收。 Promise.then()&emsp;&emsp;.then()方法用于Promise实例的状态改变时执行的回调函数。它接收两个参数，分别是状态成功时和状态失败时执行的回调函数,同时两个函数内可以传递参数供回调函数使用。 &emsp;&emsp;下面我们来创建一个Promise实例并用.then()方法执行相应的回调函数。 12345678910111213141516171819const a = 3function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; if (true) &#123; // 如果异步操作成功 resolve(value) console.log('success!') &#125; else &#123; // 异步操作失败 reject(value) console.log('fail!') &#125; &#125;)&#125;p(a).then((a) =&gt; &#123; console.log(a)&#125;, (a) =&gt; &#123; console.log(a)&#125;) &emsp;&emsp;上面的代码我们首先声明了一个属性a，紧接着在p函数里封装了一个Promise对象并返回。里面假设进行了一个异步请求。如果异步请求执行成功，执行resolve函数，并把a当作参数传递进去。如果异步请求执行失败，执行reject函数，同时也把参数a传递进去。之后我们执行了p函数，将参数a传递进去，并在.then()内写了两个箭头函数用于执行成功和失败的回调。这时运行代码控制台会输出： 12success!3 &emsp;&emsp;运行到这里说明走了resolve函数，并且获取到了传进来的参数a。如果此时将p函数内的异步操作结果修改为false，就会执行reject函数内的代码了。这里需要注意的是，success虽然写在resolve的后面，但是先于resolve执行的。因为在Promise对象里，同步代码总是先于异步代码执行。 &emsp;&emsp;这就是Promise的用法。使用Promise来封装异步请求，结构清晰，写法简明，即使有多层嵌套也不会出现回调地狱的情况。.then()方法有一个链式调用的特点。一个Promise对象会返回一个新的Promise对象，所以如果都是Promise对象的话，可以这样用（前提是都用Promise包装起来）。 123456789101112131415161718192021222324252627282930313233343536373839// 以下Promise对象省略了reject函数const json = &#123; data: &#123; list: [1, 2, 3] &#125;&#125;function p1(json) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(json.data) return resolve(json.data) &#125;, 1000) &#125;)&#125;function p2(data) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(data.list) resolve(data.list) &#125;, 1000) &#125;)&#125;function p3(list) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(list[2]) resolve(list[2]) &#125;, 1000) &#125;)&#125;p1(json).then(p2).then(p3)/* &#123;list: [1, 2, 3]&#125;[1, 2, 3]3（每行输出间隔1s）*/ &emsp;&emsp;上面的代码首先模拟了一个后台请求到的数据，一个json对象，里面包含了data对象，data对象下是一个数组。接下来分别封装了p1, p2, p3三个Promise对象函数。每一层内用setTimeout定时器模拟了执行异步请求，间隔1秒。在定时器里把当前接收到的数据的下一层打印出来，同时以resolve函数参数的形式传递出去。最后执行.then()方法的时候，我们可以看到，每一层函数都打印出了上一层传递进来的数据。也就是说，上层Promise对象传递出来的属性，.then()方法可以接收到。 Promise.catch()&emsp;&emsp;.catch()方法可以捕获到Promise对象内的错误。 1234567891011121314151617function p() &#123; return new Promise((resolve, reject) =&gt; &#123; if (false) &#123; // 如果异步操作成功 resolve() &#125; else &#123; // 异步操作失败 reject() &#125; &#125;)&#125;p() .then(() =&gt; &#123; console.log('success!') &#125;) .catch(() =&gt; &#123; console.log('fail!') &#125;) &emsp;&emsp;上面的代码用.catch()捕获了Promise对象内模拟的异步请求失败的场景，执行了reject()函数。我们也可以指定.then()方法的第二个参数，也就是执行状态失败时的回调函数来匹配错误的情况，但是实际使用中不推荐这么写，推荐使用.catch()方法来捕获错误状态，同时指定需要执行的函数。 Promise.finally()&emsp;&emsp;.finally()方法接收一个回调函数作为参数，该方法指定Promise对象的状态结束时执行的回调函数。也就是说，不管此时状态为成功还是失败，只要从Pending状态变为了其它两种状态的任意一种，都会执行.finally()方法里的回调函数。finally()方法的回调函数不接受任何参数。 1234567891011121314151617181920function p() &#123; return new Promise((resolve, reject) =&gt; &#123; if (false) &#123; // 如果异步操作成功 resolve() &#125; else &#123; // 异步操作失败 reject() &#125; &#125;)&#125;p() .then(() =&gt; &#123; console.log('success!') &#125;) .catch(() =&gt; &#123; console.log('fail!') &#125;) .finally(() =&gt; &#123; console.log('finally!') &#125;) &emsp;&emsp;上面的代码使用了.finally()方法，无论Promise对象执行的是resolve还是reject，.finally()里的回调函数都会执行！ Promise.all()&emsp;&emsp;在实际使用中，有这样一种情况。我们想监听多个Promise对象的返回情况，如果所有的Promise对象都返回成功状态，才执行成功的回调。.all()方法就是用来干这个的，它接收一个数组参数，数组里的每一项都是一个Promise对象，都返回成功时.all()方法执行成功回调，如果有一项返回失败，则执行失败回调。这个方法的回调参数接收数组内每个Promise对象返回的参数，并按照顺序将它们放到一个数组里。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(4)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; resolve(5)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; resolve(6)&#125;)Promise.all([p1, p2, p3]).then((values) =&gt; &#123; console.log('success!') console.log(values) // [4, 5, 6]&#125;) &emsp;&emsp;上面的代码先创建里3个Promise对象（省略了模拟异步请求的步骤，直接执行了resolve方法），然后将这三个Promise对象以数组的形式传递给.all()方法，同时每个Promise对象里都分别传递了一个数字参数进去。.all()方法监听到三个Promise对象状态均为成功，则执行.then()方法内的代码，打印出了success!。同时三个Promise对象传递进来的数字参数也被接收到了。 &emsp;&emsp;如果.all()方法的参数里有状态为失败的对象，则.all()方法则执行失败回调，同时接收到的参数为第一个执行reject函数时传递进来的参数。 12345678910111213141516171819const p1 = new Promise((resolve, reject) =&gt; &#123; resolve(4)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; reject(5)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; reject(6)&#125;)Promise.all([p1, p2, p3]) .then((value) =&gt; &#123; // 这里不会被执行 console.log('success!') console.log(value) &#125;) .catch((value) =&gt; &#123; // 执行这里 console.log('fail!') console.log(value) // 5 &#125;) Promise.race()&emsp;&emsp;race译为赛跑，速度竞赛，顾名思义，这个方法就是返回最先改变状态的Promise实例。直接看代码： 1234567891011121314151617181920const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(4) &#125;, 1000)&#125;)const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(5) &#125;, 800)&#125;)const p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(6) &#125;, 900)&#125;)Promise.race([p1, p2, p3]) .then((value) =&gt; &#123; console.log(value) // 5 &#125;) &emsp;&emsp;上面代码还是首先封装了三个Promise对象，里面用setTimeout定时器模拟了异步请求，分别为1000ms，800ms和900ms，并分别传递了一个数字参数进去。可以看到最终是p2先执行完，所以打印出的是800ms的p2传递进去的参数5。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新封装JavaScript里的String.indexOf()方法]]></title>
    <url>%2F2019%2Fjs-indexOF.html</url>
    <content type="text"><![CDATA[indexOF()方法&emsp;&emsp;JavaScript的String对象中有一个indexOf()方法，这个方法接收一个指定字符串参数（必须）和查找位置参数（可选）。该方法返回指定字符串在字符串中第一次出现的位置，如果没有出现，则返回”-1”。如果有传查找位置参数，则从传入的位置查起，如果没有传位置参数默认为0，即从字符串的开头查起。 &emsp;&emsp;说完了这个函数的功能，那么我们如何自己封装一个一样功能的方法呢？ &emsp;&emsp;先说思路。首先当传入了指定字符串后，我们可以将指定字符串的第一个字符作为一个变量保存起来；然后用这个变量在循环内依次和字符串相比较；如果相同，则进一步比较相同长度下，是否完全相同即可。最后返回相应的结果数值。 1234567891011121314151617181920212223242526// 重新封装String.indexOf函数// 调用方式与原生的方法略有不同，将字符串变为函数的第一个参数，其它不变// str为字符串；findStr为指定的字符串；index为查找位置，不传则默认为0function indexOF(str, findStr, index = 0) &#123; if (typeof str === 'string' &amp;&amp; typeof findStr === 'string' &amp;&amp; typeof index === 'number') &#123; // 将指定字符串的第一个字符作为一个变量保存 let firstStr = findStr[0] for(let i = index; i &lt; str.length; i++) &#123; // findStr与str中查询部分首字符相同则进一步查询 if (str[i] === firstStr) &#123; // 完全相同 if (str.substr(i, findStr.length) === findStr) &#123; return i &#125; else &#123; continue &#125; &#125; else &#123; continue &#125; &#125; return -1 &#125; else &#123; alert('function indexOF的传入参数格式有误，请重新传入正确的参数执行查询！') return undefined &#125;&#125; &emsp;&emsp;写完了来调用试验一下结果（调用方式与原生的方法略有不同）： 123console.log(indexOF('xiekaifei', 'i')) // 1console.log(indexOF('xiekaifei', 'i', 3)) // 5console.log(indexOF('xiekaifei', 'ok')) // -1 strFind()方法&emsp;&emsp;实现了这个方法后我们再来实现一个查询所有位置的方法。实现的功能是：传入字符串和指定的字符串，返回所有出现位置的数组，未找到时则返回-1。 1234567891011121314151617181920212223242526272829function strFind(str, findStr) &#123; if (typeof str === 'string' &amp;&amp; typeof findStr === 'string') &#123; let arr = [] let index = 0 for (let i = 0; i &lt; str.length; i++) &#123; // 调用刚刚封装好的indexOF()方法查询，并将查询结果暂时保存给num参数 let num = indexOF(str, findStr, index) if (num &gt;= 0) &#123; arr.push(num) index = ++num &#125; else &#123; break &#125; &#125; if (arr.length &gt; 1) &#123; // 返回所有出现的位置的数组 return arr &#125; else if (arr.length === 1) &#123; // 只出现一次的话直接返回位置 return arr[0] &#125; else &#123; // 未出现返回-1 return -1 &#125; &#125; else &#123; alert('function strFind的传入参数格式有误，期待两个字符串参数，请重新传入正确的参数执行查询！') return undefined &#125;&#125; &emsp;&emsp;再调用一下： 123console.log(strFind('xiekaifei', 'i')) // [1, 5, 8]console.log(strFind('xiekaifei', 'fe')) // [6]console.log(strFind('xiekaifei', 'ok')) // -1 &emsp;&emsp;大功告成！]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的__proto__与prototype]]></title>
    <url>%2F2019%2Fjs-prototype.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近接了几个面试，个别出色的面试官在面试技术部分的时候总是很考察被试者的原生js能力，而业务逻辑写多了就会逐渐淡忘掉最基础同时也是最重要的js知识。所以，工作的同时多复习原生js知识是非常重要的。今天就来聊一下js中__proto__和prototype。 prototype&emsp;&emsp;prototype属性即js的原型属性，是为了给所有实例添加共享属性和共享方法的属性。使用方法可见这篇文章中的“原型模式”部分。 &emsp;&emsp;prototype这个属性指向一个包含所有共享属性和共享方法的对象，我们称之为原型对象。同时这个原型对象也有一个叫做”constructor”的属性，这个属性指回的是原构造函数。 123456789function Person() &#123; this.name = 'xkf' this.age = 18&#125;Person.prototype.sayName = function() &#123; console.log(this.name)&#125;console.log(Person.prototype) // 会打印出sayName, constructor, __proto__ &emsp;&emsp;上面的代码先是创建了一个名为”Person”的构造函数，然后给这个方法的原型属性（prototype）内添加了一个所有实例共享的”sayName”方法，最后在控制台打印出了该构造函数的”prototype”属性。可以看到，prototype内包含之前添加的sayName方法，接着有constructor属性，这个属性指回原构造函数也就是它自己”Person”。最后还有一个__proto__。 __proto__&emsp;&emsp;js的每个实例对象中会有__proto__这样一个私有属性，有些人把这个属性称之为“隐式原型”，这个属性指向构造该对象的构造函数的原型属性（prototype）。 1234567function Person() &#123; this.name = 'xkf' this.age = 18&#125;var p = new Person()console.log(p.__proto__ === Person.prototype) // true &emsp;&emsp;上面的代码先是创建了一个名为”Person”的构造函数，然后基于”Person”创建了它的实例”p”。这个时候如果直接打印p的话会看到，p里面除了有继承自构造函数Person中的属性”name”和”age”之外，还有一个私有属性（隐式原型）__proto__，而它指向的就是构造该对象的构造函数（Person）的原型，所以两者在最后比较的时候会返回”true”。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的赋值、浅拷贝和深拷贝]]></title>
    <url>%2F2019%2Fjs-copy.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;js里的数据类型分为基本数据类型和引用数据类型，基本数据类型有undefined, boolean, number, string, null, Symbol(ES6中新增)，而引用数据类型就是Object。两种类型在赋值上面是有一些区别的。 赋值基本数据类型&emsp;&emsp;基本数据类型的赋值操作是直接拷贝一份原数据的副本，赋值后改变原数据的值并不会影响到副本数据的值，反之也不会相互影响。 1234var a = 1var b = aa = 2console.log(b) // 改变原数据a的值，并不会影响副本数据b的值，b输出1 引用数据类型&emsp;&emsp;而引用数据就不同了，赋值操作后改变原数据和副本数据任何一个数据的值都会影响另一个数据的值。这是因为在将一个引用数据的值赋值给副本数据后，副本数据保存的是和原引用数据相同（以下简称原数据）的指针，该指针和原数据指向同样的内存地址。其中任何一方修改这个指针的值，内存地址对应存储空间上的值发生改变后，另一方的指针指向的位置不变，所以对应指向的值也就发生了相同的改变。 123456var a = &#123; num: 10&#125;var b = ab.num = 20console.log(a.num) // 改变副本数据b.num的值，会影响到原数据a.num的值，反之也是，a.num输出20 &emsp;&emsp;因为引用数据的特性，这让我们在想进行拷贝引用数据操作时发生了问题。如果想拷贝引用数据，修改副本数据时不影响原数据的话，就要用到拷贝方法。拷贝方法又分为浅拷贝和深拷贝。 浅拷贝遍历实现浅拷贝12345678910111213141516// 我们先来创建一个a对象var a = &#123; arr: [1, 2, 3]&#125;// 再封装一个浅拷贝函数，target是要复制的副本对象，source是原对象function shallowCopy(target, source) &#123; for (let key in source) &#123; target[key] = source[key] &#125;&#125;var b = &#123;&#125; // 创建一个空的b对象shallowCopy(b, a) // 用封装好的浅拷贝函数把原对象a的值拷贝给b对象a.arr = ['一', '二'] // 修改原对象a.arr的值console.log(b) // 输出[1, 2, 3]。这时修改原数据a的值并不影响副本数据b的值 &emsp;&emsp;但是浅拷贝方法也有一个问题，继续看： 123456789// 重新创建一个c对象var c = &#123; arr: [1, [2, 3]]&#125;var d = &#123;&#125; // 重新创建一个空的d对象shallowCopy(d, c) // 用刚刚封装好的浅拷贝函数把原对象c的值拷贝给d对象c.arr[1] = ['二', '三'] // 修改原对象c.arr[1]的值，这个值是一个数组，也是一个引用数据类型的值console.log(d) // 输出[1, ["二", "三"]] &emsp;&emsp;这时修改原数据c的值，副本数据d也一起被修改了。这是什么原因呢？原来是因为浅拷贝操作只能复制一层对象的属性，并不包括对象里的引用数据类型的值，所以当修改原数据c里的数组的值后，浅拷贝的副本数据d的数组值也就一起被改变了。如果要完全独立拷贝副本数据，就需要用到深拷贝的方法了。 ES6浅拷贝数组方法&emsp;&emsp;ES6新增了扩展运算符...，可以实现数组的浅拷贝。 12345// 创建原始数组var a = [1, 2, [3, 4], 5]var b = [...a]a[1] = 100console.log(b) // 输出[1, 2, [3, 4], 5]。副本数据b并没有随着a一起改变。（仅限于浅拷贝） 深拷贝使用JSON序列化实现深拷贝&emsp;&emsp;深拷贝的一种方法是利用JSON.stringify()方法，先将原对象转化为json格式，再用JSON.parse()方法将转化后的json数据转回js对象的方式，进行深拷贝。 12345678910111213// 还是重新创建一个a对象var a = &#123; arr: [1, [2, 3]]&#125;// 这时来封装一个深拷贝函数function deepCopy(source) &#123; return JSON.parse(JSON.stringify(source))&#125;var b = deepCopy(a) // 将深拷贝后的值赋给b对象（副本对象）a.arr[1] = ['二', '三'] // 修改原数据内层引用数据类型的值console.log(b) // 输出[1, [2, 3]]。并不会影响拷贝后副本对象b &emsp;&emsp;这样，我们就可以用深拷贝的方法拷贝引用数据类型的值，随意修改原数据或副本数据的其中一个，而不用担心另一个也会被随之修改了。 递归实现对象的深拷贝&emsp;&emsp;还有一种递归实现深拷贝的方法。解决思路是先用for...in...的方法遍历原对象，检测每次遍历的值是否为对象，是的话再次调用自身递归循环遍历，不是的话直接添加。 1234567891011121314151617181920212223242526272829// 先创建原始a对象var a = &#123; person: &#123; name: 'test_a', age: 10 &#125;&#125;// 封装一个验证是否为对象的函数function isObject(obj) &#123; if (typeof obj === 'object') &#123; return true &#125; else &#123; return false &#125;&#125;// 封装递归对象深拷贝函数function deepCopy(obj) &#123; let copyObj = &#123;&#125; for (let key in obj) &#123; copyObj[key] = isObject(obj[key]) ? deepCopy(obj[key]) : obj[key] // 当遍历的数据为对象时，调用自身递归继续遍历子对象 &#125; return copyObj&#125;var b = deepCopy(a)a.person.age = 20 // 修改原对象a.person.age的值console.log(b) //输出&#123; person: &#123; name: "test_a"; age: 10 &#125; &#125;。拷贝后的子对象没有随之改变 &emsp;&emsp;这种方法只针对内部全是对象的引用数据类型。如果还想加上数组，需要再加上一层验证。 &emsp;&emsp;需要注意的是两种方法都不完美，都不支持值为Function或正则等格式的引用数据类型，需要寻找其它的解决方案。要想实现完美的深拷贝还需要考虑怎么处理原型等问题，一般在实际应用当中，基本上是没有全部需要深拷贝的情况的。上面说的两种方法在一般在业务中基本上是足够使用的。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客系统常用命令]]></title>
    <url>%2F2019%2Fhexo-command.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;我的博客使用的是Hexo框架，可以很方便的使用一些命令编辑博文，发布文章或者本地预览等操作。但是每次写文章的时候，都会忘记一部分命令（主要原因博客写的太少…）导致每次都需要google查询这些操作的命令。这次干脆总结一下常用的命令，方便下次使用。 命令 操作 hexo new title 新建一篇文章。（如果标题包含空格的话，需要使用引号括起来。）省略了layout参数 hexo generate（可简写为hexo g） 生成静态文件，可加参数-d，生成静态文件后部署网站 hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo server（可简写为hexo s） 启动本地服务器 hexo deploy （可简写为hexo d） 部署网站，可加参数-g，部署之前预先生成静态文件 hexo version 显示 Hexo 版本 &emsp;&emsp;以上就是hexo最常用的命令，文章编辑完成准备发布的时候，可直接使用以下命令，一次搞定： 1hexo g -d // 生成静态文件并部署网站 &emsp;&emsp;如果想一次使用多条命令，也可以用&amp;&amp;连字符来连接多条命令。比如文章编辑好想先在本地预览效果： 1hexo g &amp;&amp; hexo s // 生成静态文件后，启动本地服务器 更多Hexo 指令]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用编辑快捷键]]></title>
    <url>%2F2019%2Fvim-edit.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;在使用终端的时候，免不了会使用vi/vim编辑器来编辑文件。下面罗列一些编辑时的常用快捷键，可以提高使用效率。完整版的vim使用教程见最底部的引用链接。 按键 操作 h或左箭头键 光标向左移动一个字符 j或下箭头键 光标向下移动一个字符 k或向上箭头键 光标向上移动一个字符 l或向右箭头键 光标向右移动一个字符 行数后跟移动按键组合键，如30j 光标向下移动30行 Ctrl + f 屏幕向下移动一页 Ctrl + b 屏幕向上移动一页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n后跟space键 n表示数字，表示光标向右移动n个字符 0或Home键 光标移动到这一行最前面的字符处 $或End键 光标移动到这一行最后面的字符处 H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n后跟Enter键 n 为数字。光标向下移动 n 行(常用) 完整快捷键列表见vi/vim使用教程]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vi/vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript创建ajax异步请求]]></title>
    <url>%2F2019%2Fjs-ajax.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;利用ajax，可以创建异步请求，从而实现在不影响整个页面的情况下，局部更新网页某处的数据。 &emsp;&emsp;异步请求可以应用在多个地方，最常见的就是我们在注册某个网站账号的时候，输入要注册的用户名，当鼠标焦点离开用户名输入表单的时候，如果输入的用户名已经存在于网站内，右侧会给出有相同用户名的提示。试想如果没有该功能，用户就必须在所有信息都填写完毕的情况下，点击”提交”按钮，才能知道用户名是否可以使用，大大降低效率。 创建XMLHttpReques对象&emsp;&emsp;先用js来写，第一步用构造函数初始化一个XMLHttpReques对象。 1var request = new XMLHttpRequest() &emsp;&emsp;目前新版本的浏览器基本都支持XMLHttpReques对象，只有像IE5/IE6这种老旧的浏览器不支持，需要改用ActiveX对象。当然你也可以在使用XMLHttpReques前来做一个判断，以保证更强的兼容性。 1234567var requestif (window.XMLHttpRequest) &#123; request = new XMLHttpRequest()&#125; else &#123; // IE5/IE6下使用 request = new ActiveObject('Microsoft.XMLHTTP')&#125; 使用onreadystatechange监听是否加载完成&emsp;&emsp;创建完成后，使用onreadystatechange来监听readyState和status属性的改变。 12345request.onreadystatechange = function() &#123; if (request.readyState === 4 &amp;&amp; request.status === 200) &#123; // 需要执行的代码 &#125;&#125; &emsp;&emsp;首先来说一下onreadystatechange。这个方法会在readyState属性发生改变时触发readystatechange事件的时候被调用。 &emsp;&emsp;接着是readyState和status属性。 readyState: XMLHttpRequest.readyState 属性返回一个 XMLHttpRequest 代理当前所处的状态。一个 XHR 代理总是处于下列状态中的一个： 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 引用自MDN XMLHttp​Request​.ready​State status:&emsp;&emsp;status属性则返回一个响应中的数字状态码，比如”200”代表一个成功的请求。 向服务器发送请求&emsp;&emsp;首先用open()方法来初始化一个请求。 open()1request.open('GET', './text.json') &emsp;&emsp;open()有三个参数，第一个指定要使用的http方法，如GET方法或者POST方法，第二个参数指定要向其发送请求的url，第三个参数是一个布尔值，表示是否用异步执行操作，默认为ture，表示使用异步执行。 send()1request.send() &emsp;&emsp;send()表示发送请求。 实际使用示例比如同目录下有一个名为”text.json”的json文件： 123456&#123; "student": [ &#123;"name": "小明", "age": 12&#125;, &#123;"name": "小红", "age": 13&#125; ]&#125; 要实现点击按钮，获取小明的年龄，html代码如下： 123456&lt;body&gt; &lt;button type="button" id="btn"&gt;click me&lt;/button&gt; &lt;div&gt; 小明的年龄为：&lt;span id="age" style="color: red;"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; js代码如下： 12345678910111213141516var btn = document.getElementById('btn')var age = document.getElementById('age')var request = new XMLHttpRequest()var studentrequest.open('GET', './text.json')request.onreadystatechange = function() &#123; if (request.readyState === 4 &amp;&amp; request.status === 200) &#123; // 获取json文件的值，并转换为js对象 student = JSON.parse(request.responseText).student &#125;&#125;request.send()btn.onclick = function() &#123; age.innerHTML = student[0].age&#125; &emsp;&emsp;上面的代码还用到了responseText()和JSON.parse()两个方法。 responseText()&emsp;&emsp;该方法返回从服务器接收到的字符串。 JSON.parse()&emsp;&emsp;该方法将一个json字符串转换为js对象。还可以添加一个转换结果函数，为该方法的第二个参数，将为对象的每个成员调用该方法。 跨域&emsp;&emsp;异步请求json文件，该文件直接使用的话必须与调用文件为同协议、同地址、同端口才能正常实现功能。如跨域使用需要使用其他方法来实现，本文没有提到跨域相关的内容，以后有机会再来谈一谈跨域。]]></content>
      <categories>
        <category>技术</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下使用自带终端ssh连接服务器]]></title>
    <url>%2F2019%2Fmac_ssh.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前在Windows环境下都是用PuTTY这款软件来连接和保存远程服务器地址的，而在Mac OS下可以使用自带的终端(terminal)直接连接和保存，非常方便。 1.直接连接&emsp;&emsp;首先打开Mac下的终端，输入：ssh -p 端口号 服务器用户名@ip，例如： 1ssh -p 22 root@192.168.1.8 &emsp;&emsp;然后终端会让你输入yes或no来询问你是否连接，输入yes后，再输入服务器该账户下的密码，回车，最后连接成功。 2.保存服务器别名连接&emsp;&emsp;第一种方法可以直接连接，但是服务器一多，没人记得住所有的连接信息，所以就需要提前把连接信息保存起来并取一个别名，方便以后登录。 &emsp;&emsp;第一步还是先打开终端，使用vim命令编辑~/.ssh路径下的config文件。 12345678910#服务器1Host 服务器别名 HostName ip地址 Port 22 User 用户名#服务器2Host 服务器别名 HostName ip地址 Port 22 User 用户名 &emsp;&emsp;添加好连接信息后，保存，终端下输入ssh 服务器别名，输入密码连接即可。]]></content>
      <categories>
        <category>技术</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js实例的生命周期]]></title>
    <url>%2F2019%2Fvue.js-lifecycle.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;vue实例有一个完整的生命周期，先上一段vue.js官网对vue实例生命周期的解释： 每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。 &emsp;&emsp;同时，在这个过程中，会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 &emsp;&emsp;上面这张图是vuejs官网vue实例章节中给出的vue实例生命周期图示，下面我来逐项解释图中的每一步当中生命周期钩子函数的用法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var test = new Vue(&#123; el: '#app', data: &#123; message: 'Hello' &#125;, /* 结合上面的生命周期图来看，首先是第一步创建一个vue对象new Vue(),然后vue实例进行 基础的初始化操作(Init Events &amp; Lifecycle)之后，就会进入到beforeCreate函数，这时 控制台会输出“undefined beforeCreate"，这是因为此时vue还没有监控data对象数据的变化， 所以this.message会输出“undefined” */ beforeCreate: function() &#123; console.log(this.message + ' beforeCreate') &#125;, /* beforeCreated函数执行完毕后，vue实例会初始化剩下的部分，接着执行created函数， 下面的函数会在控制台输出“Hello created”,此时vue实例都已初始化完毕，this.message可以被输出 */ created: function() &#123; console.log(this.message + ' created') &#125;, /* created函数执行完毕后，会询问实例中是否有"el"选项，本test实例中有el实例，接着会询问是否有 "template"模板，本实例中没有定义，所以会走No分支，会把当前el的整体内容当做模板。 那么此时的模板，就是当前HTML文件内，id为"app"标签的所有内容。如果实例中有"template"， 模板即为"template"属性中的内容。 接着往下走到了beforeMount函数，下面的函数会在控制台输出"Hello beforeMount"，此时 页面还没有将编译出的HTML文件渲染到页面上，beforeMount函数正是此时执行的函数。 */ beforeMount: function() &#123; console.log(this.message + ' beforeMount') &#125;, // 到了mounted函数执行的时候，此时模板已经挂载完成，HTML内容已经被渲染到了页面上。 mounted: function() &#123; console.log(this.message + ' mounted') &#125;, beforeDestroy: function() &#123; console.log(this.message + ' beforeDestroy') &#125;, destroyed: function() &#123; console.log(this.message + ' destroyed') &#125;, /* beforeDestroy和destroyed分别是在实例销毁之前和实例销毁之后执行的函数， 此时如果我们在控制台使用"test.$destroy()"方法来销毁该实例的话，控制台会输出 Hello beforeDestroy Hello destroyed undefined 说明beforeDestroy()和destroyed()两个函数分别先后得到了执行，同时销毁了test实例 */ beforeUpdate: function() &#123; console.log(this.message + ' beforeUpdate') &#125;, updated: function() &#123; console.log(this.message + ' updated') &#125; /* beforeUpdate和updated函数分别是当数据改变时，会在 DOM 更新前和更新后分别执行的两个函数， 此时如果我们在控制台执行"test.message = 'Hi'"，控制台会输出 Hi beforeUpdate Hi updated "Hi" 说明beforeUPdate()和updated()两个函数分别在数据改变前后得到了执行 */&#125;) &emsp;&emsp;生命周期函数就是vue实例在某一个时间点会自动执行的函数，我们可以通过在vue实例运行过程中的不同时间点来嵌入不同的函数，以此来实现相应的功能。]]></content>
      <categories>
        <category>技术</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019春运回家路]]></title>
    <url>%2F2019%2Fgohome.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;转眼间又要过年了，又到了号称“人类史上最大规模迁徙”的春运，而我自从毕业参加工作以后，也是每年都参与其中。今年是我工作地距离家最远的一次，重庆到张家口宣化，地图显示开车到家需要20小时左右，1733公里，因为我还没有车（当然即使有也不会这么远开车回家），所以早早的也加入了抢票大军。今年的假期还算比较长，年假、假期加上老板今年心情美丽（这里要感谢老板），额外给了三天带薪年假，算下来一共有20天的时间，可以好好的回家耍一耍了。 &emsp;&emsp;先说一下行程，重庆到宣化和张家口都没有直达的火车，所以必须从离家比较近的北京中转，路程就变为了“重庆—北京—宣化”。原本计划的是坐火车回家，也提前在智行上抢到了两程的火车票。某天在小胖妹儿的提醒下看了机票，正好看到海航有重庆至北京的特价机票，赶紧退了重庆到北京的火车票，买了机票回家，算下来相比18个小时的火车票，坐飞机节省了15个半小时，而且当天就能到家，还是相当不错的。 &emsp;&emsp;回家这天是早上8点20的飞机，上午10点40到北京。由于住的地方离机场有些远，所以当天早上5点就起来了，洗漱完毕后，打车赶10号线最早的一班地铁，别问为什么，因为穷，打车到10号线的起始站鲤鱼池地铁站比直接打车到机场省了50块钱左右，用的时间还差不多，所以本着节俭朴素的原则还是选择这种方式到机场。 &emsp;&emsp;6点钟出门，天还没亮，平时小区门口一条热闹的美食街此时也是冷冷清清的。 &emsp;&emsp;穿过这条街前的马路上，倒是已经有不少汽车了，还能看到早早就出摊的卖早点的人，他们也是蛮辛苦的。 &emsp;&emsp;打车20分钟左右到了鲤鱼池地铁站，此时是6点半，正好赶上首班地铁。从地铁口下去的时候，下了五节下图这么长的电梯，网上查了一下，鲤鱼池地铁站埋深76米，相当于住宅楼27层高，不禁感叹我国的基建水平真的是突飞猛进。 &emsp;&emsp;40分钟左右从鲤鱼池站到了江北机场T3航站楼。今年回家比较早，是春运刚开始的第3天，没有到高峰期，但还是能看出来机场的人比以往要多一些。 &emsp;&emsp;带的东西不算太多，只有一个20寸的登机箱，装了一些换洗衣服，安检也比较顺利。 &emsp;&emsp;8点前成功登机，这次坐的是海航的78A，也就是波音787-9，属于中长型宽体客机，经济舱采用的是3+3+3的座椅布局，相较于比较热门的中短程窄体客机空客A320和波音737要大了一些。目前民航中采用的基本都是空中客车和波音公司生产的客机，不知道什么时候能坐上中国的C919。登机以后天还没完全亮，我坐在靠窗正对机翼的位置，还可以看看窗外的风景。 飞行途中蓝蓝的天： &emsp;&emsp;这架飞机上是有wifi的，但是不知道为什么不能用，所以全程基本上是睡了过去。快到北京的时候天已经完全亮了。 首都机场上空准备降落： &emsp;&emsp;大约10点40，到了首都机场T1航站楼。下午要到北京站去坐火车，准备坐地铁机场线过去，T1航站楼没有直接连通机场线，要走大约10分钟到T2航站楼坐车。 &emsp;&emsp;由于时间还早，转车的时候到东直门附近转了转，在东直门桥上随手拍了一张，北京的太阳是真的好，不像重庆的冬天，很少能见到太阳。 &emsp;&emsp;下午三点到了熟悉的北京站，唯一感觉就是人多，站前广场上站满了准备回家的人，就连各个候车室里也是人满为患，座位基本没有空出来的，还好一会就可以检票上车了，不用在车站停留很久。 &emsp;&emsp;我坐的是北京到沙岭子西的Y537次列车，张家口南站由于冬奥会正在扩建，所以现在到张家口南站的车都改到距离此站大约10公里左右的沙岭子西站。张家口的机场目前也在扩建，今年的3月就可以恢复运营了，如果到时候能开通重庆到张家口的航班就好了，这样以后回家就方便太多。希望家乡能借冬奥会之势，发展的越来越好！ 踏上回家的列车： &emsp;&emsp;2个半小时的车程很快就过完了，老妈来到火车站接我，此时已经天黑了。回到家吃上了热乎的饭菜，和老爸老妈小酌几杯，说说一年当中的酸甜苦辣。 &emsp;&emsp;整整一天的回家路，奔波1900余公里，顺利到家。至此，旅途结束。最后，祝愿那些和我一样在外工作的人，都能在春运期间买到车票，顺利的走完回家的路！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>春运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承]]></title>
    <url>%2F2018%2Fjs-inheritance.html</url>
    <content type="text"><![CDATA[原型链继承&emsp;&emsp;上篇《JavaScript中的构造函数及原型模式》的文章里提到了只要创建了一个新函数，就会为该函数创建一个prototype属性（指向函数的原型对象），所有的原型对象都会自动获得一个constructor属性，这个属性包含一个指向构造函数的指针。下面先看代码： 123456789101112131415161718192021function One() &#123; this.a = 'a' this.num = [1, 2]&#125;One.prototype.sayName = function () &#123; console.log('xiaoming')&#125;function Two() &#123;&#125;Two.prototype = new One() // 直接把继承函数prototype指向的构造函数改为被继承的构造函数var two = new Two()two.sayName() // 控制台打印"xiaoming"，继承了One()的方法var two2 = new Two()two2.num.push(3)two2.a = 'b'two2.num // 输出[1, 2, 3]two.num // 输出[1, 2, 3]two2.a // 输出btwo.a // 输出a &emsp;&emsp;上面的代码将继承函数Two()的prototype直接修改为了构造函数One()的实例，继承了One()的方法，所以实例two在调用sayName()方法会直接输出xiaoming，而被继承函数One()的num属性也被继承了下来。但是当第二个实例two2修改num属性的时候，第一个实例two的num属性也被随之修改了，因为所有实例共享的是一个num属性，这就是原型链继承的缺点。当然这个缺点只是针对引用数据类型，而基本数据类型不受这个影响，这一点可以从a属性的修改中看出。 借用构造函数&emsp;&emsp;直接看代码吧： 12345678910111213141516function One(name) &#123; this.name = name this.sayName = function() &#123; console.log(this.name) &#125;&#125;One.prototype.sayHi = function() &#123; console.log('Hi!')&#125;function Two() &#123; One.call(this, 'xiaoming')&#125;var two = new Two('xiaoming')two.sayName() // 控制台打印"xiaoming"two.sayHi() // 报错 &emsp;&emsp;上面的继承函数Two()使用了call()方法，使用了被继承函数One()的方法替换了自己的方法，所以实例two在调用sayName()的时候成功输出”xiaoming”，而且在调用的方法的时候还可以传参数进去，这里也可以使用apply()方法，与call()不同的是apply()的第二个参数是一个数组，call()可以只传入第一个参数，也可以在第一个参数后依次传入多个参数。 &emsp;&emsp;使用这种方法也实现了继承，但是这种方法也有缺点，就是继承函数只能继承构造函数内的属性和方法，原型内的属性和方法对于继承函数来说是不可见的。这就是为什么最后调用two.sayHi()方法会报错了。 组合继承&emsp;&emsp;《JavaScript高级程序设计》一书中说组合继承有时也被叫做伪经典继承，指的是将原型链继承和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。这样既通过在原型定义方法实现了函数的复用，又能保证每个实例都有它自己的属性。 1234567891011121314151617181920function One(name) &#123; this.name = name this.num = [1, 2]&#125;One.prototype.sayHi = function() &#123; console.log('Hi!')&#125;function Two(name) &#123; // 继承属性 One.call(this, name)&#125;Two.prototype = new One() // 继承方法var two = new Two('xkf')var two2 = new Two('xkf')two.name // 输出'xkf'two2.num.push(3)two.num // 输出[1, 2]two2.num // 输出[1, 2, 3]two.sayHi === two2.sayHi // true &emsp;&emsp;这种继承方法就是将前两种继承方法组合到了一起，集合了两种方法的优点，既能保证多个被继承实例拥有各自的属性或方法（如上面代码中的num属性），又能共享原型中的属性或方法（上面的sayHi()方法返回true说明两个实例共享一个方法），是比较常用的一种继承方法。 寄生组合式继承&emsp;&emsp;在ES5中，尽管组合继承看起来很完美，但是也有缺点。上面组合继承方法内示例代码的第10行One.call(this, name)和第12行Two.prototype = new One()，我们分开来说。第12行先是将Two.prototype指向了One的实例，这时Two的prototype得到了num数组（name属性的值需要传入，不考虑第10行的话这个属性并没有获取到），这是第一次调用构造函数One。第10行采用了构造函数继承的方法，这个时候num数组又被创建了一次，这第二次调用构造函数One创建的num数组屏蔽了上一次原型内的num数组，所以这两次调用导致了数组num被创建了两次，造成了不必要的浪费。 &emsp;&emsp;所以我们可以使用寄生组合式继承的方法来实现较完美的继承。 123456789101112131415161718192021function One(name) &#123; this.name = name this.num = [1, 2]&#125;One.prototype.sayHi = function () &#123; console.log('Hi!')&#125;function Two(name) &#123; // 继承属性 One.call(this, name)&#125;Two.prototype = Object.create(One.prototype) // 调用Object.create()方法来修改原型Two.prototype.constructor = Two // 将构造函数指回自己var two = new Two('xkf')var two2 = new Two('xkf')two.name // 输出'xkf'two2.num.push(3)two.num // 输出[1, 2]two2.num // 输出[1, 2, 3]two.sayHi === two2.sayHi // true &emsp;&emsp;我们用了一个Object.create()方法，这个方法会创建一个新对象，并使用第一个参数提供的现有对象来作为新创建对象的__proto__，并将这个新对象作为返回值。具体实现如下（本方法有两个参数，下面展示的只是第一个参数的实现，摘自《JavaScript高级程序设计》6.3.4）： 12345function object(o) &#123; function F() &#123; &#125; F.prototype = o return new F()&#125; &emsp;&emsp;我们将One.prototype作为Object.create()的第一个参数执行后赋值给了Two.prototype，这时num数组自然可以得到继承。下面一行我们重新把Two的构造函数指回了它自己，使得后面传入的name属性也可以被创建。 &emsp;&emsp;所以在ES5中，寄生组合式继承算是一个相对完美的继承方法。 class继承&emsp;&emsp;ES6中新引入了class关键字，并且加入了class继承。这种方法通过extends来实现继承，减少了使用继承的代码量，使代码变的更加清晰易懂。 1234567891011121314151617181920class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; sayName() &#123; console.log(this.name) &#125;&#125;class Xm extends Person &#123; constructor(name, age, job) &#123; super(name, age) // 使用"super"来调用父类Person中的name和age，且必须在this之前 this.job = job &#125; sayHi() &#123; console.log('Hi!') &#125;&#125;var xm = new Xm('xiaoming', 24, 'Engineer') &emsp;&emsp;上面的代码先用class关键字定义了Person，然后Xm用intends继承了Person。这里需要注意的是，子类在继承父类的时候必须先在自己的构造函数（constructor）里调用super方法，而且要写在this之前，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 &emsp;&emsp;如果子类没有定义constructor方法，那这个方法会被默认添加。也就是说，不管有没有显式定义，任何子类都有constructor方法。]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的构造函数及原型模式]]></title>
    <url>%2F2018%2Fjs-constructor.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天详细了解了一下JavaScript中构造函数和原型模式的相关知识，做了一个总结，以便日后做一个参考。 构造函数&emsp;&emsp;构造函数可以用来创建特定类型的对象。先来看一个构造函数： 12345678910111213function Person(name, age) &#123; this.name = name this.age = age this.sayName = function() &#123; console.log(this.name) &#125;&#125;var xm = new Person("小明", 20) // 这句代码干了四件事// 1.创建了一个新对象 2.将Person的作用域赋值给新对象 3.执行Person内的代码 4.将这个新对象返回给xmxm.name // 小明xm.age // 20xm.sayName() // 控制台打印小明的名字 &emsp;&emsp;声明构造函数按照惯例通常以一个大写字母来开头，构造函数的新实例用new操作符创建。任何函数用new操作符来调用就是构造函数，而构造函数不通过new操作符调用也就和普通函数没什么两样。 &emsp;&emsp;使用构造函数的缺点是每个方法都需要在每个实例上重新创建一遍。看下面代码： 12var xf = new Person("小芳", 20)console.log(xm.sayName === xf.sayName) // false &emsp;&emsp;我在这里新建了一个名为xf的实例，这时xm和xf都有一个sayName()方法，但这两个方法如果去比较的话却是不一样的。这就说明两个方法是独立的，每个方法都会为其分配一定的内存用来存放，这样显然是浪费资源的。这时就需要提到另一种方法，原型模式。 原型模式12345678910111213// 构造函数function Person(name) &#123; this.name = name&#125;// 原型模式Person.prototype.age = 20Person.sayName = function() &#123; console.log(this.name)&#125;var xm = new Person("小明")var xf = new Person("小芳")console.log(xm.sayName === xf.sayName) // true &emsp;&emsp;上面我使用了构造函数和原型模式混合的方法，其中name属性是构造函数创建的，age属性和sayName()方法是用原型模式（prototype属性）创建的。原型模式创建的两个方法均为所有实例共享，所以在最后比较两个实例的sayName()方法时返回了true，表示两者是调用的同一个sayName()方法。 &emsp;&emsp;只要创建了一个新函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有的原型对象都会自动获得一个constructor(构造函数)属性，这个属性包含一个指向prototype属性所在函数的指针，也就是指向构造函数。在上面的例子里Person.prototype.constructor指向构造函数Person。 1234567xf.age = 25 // 重写了小芳的年龄xf.age // 25xm.age // 20/* 重写已经存在于原型的值后，用该实例访问该属性会返回重写后的值，这种情况会把原型中的该值屏蔽掉，但是不会影响其他实例调用原型中的属性。如果需要删除实例属性，可以使用"delete"操作符完全删除实例属性。*/delete xf.agexf.age // 20 原型链&emsp;&emsp;也就是说，当访问实例的属性或方法时，首先会按照名称查找实例中有没有存在的属性或方法，有的话则屏蔽原型内的同名属性或方法（原型里有的话），直接调用实例中的。如果没有，则向上查找该实例的原型，原型里有的话就调用，都没有的话就返回undefined。这个步骤是沿着原型链查找的，也就涉及到了原型链的概念。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，则都是从Object继承而来的。&emsp;&emsp;这么来理解的话，刚刚创建的xm实例的原型链是：1xm → Person.prototype → Object.prototype → null]]></content>
      <categories>
        <category>技术</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更自由的WordPress小工具插件！]]></title>
    <url>%2F2018%2Fwp-plugin.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在编辑博文的时候，发现默认的wordpress主题，文章页面在加了博客边栏小工具后变的很窄，导致有图片的文章会显示的很小，横向的图片更是显示的很难看。于是google了一下，发现有一款名为”Widget Logic”插件可以做到在指定的页面隐藏小工具组件，于是马上下载安装，试了后发现达不到想要的效果。这种插件只能在指定页面隐藏小工具，让其不显示，但并非完全去除，页面的布局还是没有更改，看起来还是很丑。&emsp;&emsp;后来偶然发现一款名字叫“Widget Options”的插件，可以设置特定页面小工具的隐藏或显示。并且与上面那一款不同，是完全把指定页面的小工具去除掉，文章页面排版看起来终于正常。]]></content>
      <categories>
        <category>技术</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某天，重庆的早晨]]></title>
    <url>%2F2018%2Fchongqing-morning.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;来重庆一周了，今天周末，起了个大早看看这座城市的一角。重庆这边的雨一下就是一周，来重庆的这一周基本每天都有雨，下下停停，基本上都是牛毛细雨，这种程度的小雨我几乎是不打伞的，淋在身上凉凉的还挺舒服。今天早上没有下雨，但还是一直阴天。 &emsp;&emsp;我租住在一个09年的老小区，小区里很多老人和孩子，环境倒也说的过去。重庆这边的楼房都蛮高，一座连着一座。下楼先拍一张，再去外面转转。 &emsp;&emsp;从我住的小区出来，穿过一条商业街，马路对面就是公司了。公司楼下是重庆奥体中心，昨天下班的时候看到奥体中心前的广场在搭台子，以为是中秋节要有什么活动，早上出来一看已经弄好了，原来是在搞车展。 重庆轨道交通2号线： &emsp;&emsp;下面来说说重庆的轨道交通。我一直觉得重庆轨道交通的发展还是相当不错的，无论从线路密集程度还是从开通时间（2004年）来说，在中国都算是排名靠前的。轨道交通有轻轨和地铁，有一种说法是地上的叫轻轨，地下的叫地铁，这种说法是完全错误的。想必大多数人都不太清楚这两者间的区别，我自己也是经常把两者搞混。下面先贴两段维基百科里定义的轻轨。 &emsp;&emsp;中华人民共和国所指的“轻轨”曾经与英文中的“Light rail”具有完全不同的含义。中华人民共和国建设部与国家发展和改革委员会1999年发布的《城市快速轨道交通工程项目建设标准》规定：按线路远期单向客运能力（断面运量），城市快速轨道交通线路分为三类线路运能等级。单向运能3.0至7.0万人次的线路为地铁，单向运能1.0至3.0万人次的线路为轻轨。 &emsp;&emsp;2008年重新修订的《城市轨道交通工程项目建设标准》（建标104-2008）取消了“轻轨”与“地铁”的区分，仅根据运能将线路分为Ⅰ、Ⅱ、Ⅲ、Ⅳ四个等级，并指出：“Ⅰ、Ⅱ、Ⅲ级线路是全封闭快速系统，采用独立的专用轨道和信号，高密度运行。Ⅳ级线路具有专用轨道和部分信号的中低运量系统，但部分路段设置平交道口。” &emsp;&emsp;所以，按照目前的建设标准来说，已经没有轻轨与地铁之分了，只有运量等级的差别，地铁的运量是要高于轻轨的。比如我拍的重庆轨道交通2号线，只有4节车厢（每趟车的车厢数可能不同），对比我之前经常坐的北京地铁昌平线的4组4节车厢来说，是要短很多的，同时客运量也少的多。不过重庆这边地势较为复杂，2号线修建地铁难度较大，只能采用修建轻轨的解决方案。不过轻轨也有轻轨的好处，重庆轨道交通2号线还是创造了很多世界之最的。 以下内容引用自百度百科“重庆轨道交通二号线”词条。 &emsp;&emsp;采用跨座式单轨系统，正线最小曲线半径150m，最大限坡60‰，较好地适应了重庆市区地形起伏、道路狭窄的特点。2号线是中国在运营城市交通中落差最大的一条，总高程落差达115米，创下世界城市轨道交通之最。 &emsp;&emsp;采用橡胶轮（内充高压氮气）+PC轨道梁，运行噪声及震动远远低于采用钢轮钢轨的传统地铁，因此2号线通过的居民区均不再另外安装声屏障。经过5年的运行，被誉为「中国最安静的轨道交通线」。 时代天街： &emsp;&emsp;时代天街这里看到一处jeep的展台，工作人员正在安装用来展示jeep越野能力的交叉轴。 &emsp;&emsp;贴一张公司办公楼的图（最瘦最高那个就是)。 &emsp;&emsp;往回家走的时候路过菜市场，偷拍了一张（没好意思进去拍）。 &emsp;&emsp;周末早晨的人还是挺多的，有正在跑步运动的人，也有跳广场舞锻炼的大妈，更有匆匆赶路上班的年轻人，感觉重庆还是一个挺有朝气的城市。 &emsp;&emsp;走了这么久也有点饿了，最后以一碗12块的肥肠小面结尾，香！]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初建博客]]></title>
    <url>%2F2018%2Fhello-blog.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前一直有想搭建一套个人博客系统的想法，正好手里有一台闲置的VPS，经过两天的折腾，在踩了无数个坑后，终于算是把博客初步建立起来。从Linux、Nginx，到MySql、PHP，慢慢体会到了建站的乐趣。以后会不定期更新博文，用来记录一些生活上的事情以及个人学习的过程。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>
